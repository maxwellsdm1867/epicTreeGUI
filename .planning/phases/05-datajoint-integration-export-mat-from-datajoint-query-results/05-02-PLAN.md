---
phase: 05-datajoint-integration-export-mat-from-datajoint-query-results
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - /Users/maxwellsdm/Documents/GitHub/datajoint/next-app/api/app.py
  - /Users/maxwellsdm/Documents/GitHub/datajoint/next-app/src/app/components/ResultsViewer.js
autonomous: false

must_haves:
  truths:
    - "User can click 'Export to epicTree' button in the DataJoint web UI results panel"
    - "Flask endpoint /results/export-mat triggers .mat file generation from current query results"
    - "Browser downloads the generated .mat file automatically"
    - "Error messages display in UI snackbar when export fails (no query, MEA data, etc.)"
    - "MEA experiments produce a user-friendly error message, not a stack trace"
  artifacts:
    - path: "/Users/maxwellsdm/Documents/GitHub/datajoint/next-app/api/app.py"
      provides: "Flask /results/export-mat endpoint"
      contains: "export-mat"
    - path: "/Users/maxwellsdm/Documents/GitHub/datajoint/next-app/src/app/components/ResultsViewer.js"
      provides: "Export to epicTree UI button"
      contains: "Export to epicTree"
  key_links:
    - from: "ResultsViewer.js"
      to: "/results/export-mat"
      via: "axios POST"
      pattern: "export-mat"
    - from: "app.py"
      to: "python/export_mat.py"
      via: "import"
      pattern: "from export_mat import"
---

<objective>
Wire the Flask endpoint and UI button so users can export DataJoint query results as .mat files from the web interface.

Purpose: This makes the export functionality accessible to users through the existing DataJoint web app — the whole point of Phase 05.

Output: Working Flask endpoint + "Export to epicTree" button in the results panel.
</objective>

<execution_context>
@/Users/maxwellsdm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/maxwellsdm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-datajoint-integration-export-mat-from-datajoint-query-results/05-01-SUMMARY.md
@/Users/maxwellsdm/Documents/GitHub/datajoint/next-app/api/app.py
@/Users/maxwellsdm/Documents/GitHub/datajoint/next-app/src/app/components/ResultsViewer.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Flask /results/export-mat endpoint</name>
  <files>/Users/maxwellsdm/Documents/GitHub/datajoint/next-app/api/app.py</files>
  <action>
    Add the Flask endpoint for .mat export to app.py. This goes in the "3: Results methods" section alongside the existing download-results endpoint.

    **At the top of app.py**, add imports:
    ```python
    from flask import Flask, session, request, jsonify, send_file
    import sys
    # Add epicTreeGUI python module to path
    EPICTREE_PYTHON_PATH = os.path.abspath("../../epicTreeGUI/python")
    sys.path.insert(0, EPICTREE_PYTHON_PATH)
    ```

    Note: `send_file` needs to be added to the existing Flask import line (it already imports Flask, session, request, jsonify).

    **Add the endpoint** after the existing `/results/download-results` endpoint (around line 384):

    ```python
    @app.route('/results/export-mat', methods=['POST'])
    def export_mat_file():
        """Export current query results to epicTreeGUI .mat format."""
        if not query or not username or not db:
            return jsonify({"message": "Run a query first!"}), 400

        try:
            from export_mat import export_to_mat

            # Reuse existing query traversal with full metadata
            tree_data = generate_tree(query, exclude_levels if exclude_levels else [], include_meta=True)

            if not tree_data:
                return jsonify({"message": "No data to export. Run a query with results first."}), 400

            # Ensure download directory exists
            if not os.path.isdir(download_dir):
                os.mkdir(download_dir)

            # Call export function
            filepath = export_to_mat(
                tree_data=tree_data,
                username=username,
                download_dir=download_dir
            )

            # Return file for download
            return send_file(
                filepath,
                as_attachment=True,
                download_name=os.path.basename(filepath),
                mimetype='application/x-matlab-data'
            )

        except ValueError as e:
            # Expected errors (e.g., MEA data not supported)
            return jsonify({"message": str(e)}), 400
        except ImportError:
            return jsonify({"message": "Export module not found. Ensure epicTreeGUI/python/ is accessible."}), 500
        except Exception as e:
            import traceback
            traceback.print_exc()
            return jsonify({"message": f"Export failed: {str(e)}"}), 500
    ```

    **Key design decisions:**
    - Uses `generate_tree()` (not `generate_object_tree()`) with `include_meta=True` because generate_tree already includes `responses` and `stimuli` for epochs when include_meta=True (see query.py lines 196-200)
    - Lazy import of `export_mat` inside the handler so the module doesn't need to be present at Flask startup
    - ValueError caught separately for user-facing errors (MEA not supported)
    - ImportError caught for missing module (deployment issue, not user error)
    - Uses existing `download_dir` global for file storage
    - `send_file` with `as_attachment=True` triggers browser download
  </action>
  <verify>
    - Flask app starts without import errors (the export_mat import is lazy, inside handler)
    - Endpoint exists at /results/export-mat
    - Returns 400 with message when no query is active
  </verify>
  <done>
    Flask endpoint /results/export-mat exists and handles success/error cases. Returns .mat file as download on success, JSON error messages on failure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add "Export to epicTree" button in ResultsViewer UI</name>
  <files>/Users/maxwellsdm/Documents/GitHub/datajoint/next-app/src/app/components/ResultsViewer.js</files>
  <action>
    Add an "Export to epicTree" button to the ResultsViewer component, placed in the existing ButtonGroup alongside the "Download ..." button.

    **Add handler function** (after handleDownload, around line 97):

    ```javascript
    const handleExportMat = () => {
        axios.post('http://localhost:3000/api/results/export-mat', {}, {
            responseType: 'blob'
        })
        .then(response => {
            // Create download link for the .mat file
            const url = window.URL.createObjectURL(new Blob([response.data]));
            const link = document.createElement('a');
            link.href = url;
            // Extract filename from Content-Disposition header, or use default
            const contentDisposition = response.headers['content-disposition'];
            const filename = contentDisposition
                ? contentDisposition.split('filename=')[1]?.replace(/"/g, '')
                : `epictree_export_${new Date().toISOString().slice(0,10)}.mat`;
            link.setAttribute('download', filename);
            document.body.appendChild(link);
            link.click();
            link.remove();
            window.URL.revokeObjectURL(url);
            setOpen(true);
            setResponse("Exported to epicTree .mat format successfully!");
            setError(null);
        })
        .catch(error => {
            // For blob responses, error message is in the blob - parse it
            if (error.response && error.response.data instanceof Blob) {
                error.response.data.text().then(text => {
                    try {
                        const json = JSON.parse(text);
                        setOpen(true);
                        setError(json.message || "Export failed");
                        setResponse(null);
                    } catch {
                        setOpen(true);
                        setError("Export failed");
                        setResponse(null);
                    }
                });
            } else {
                setOpen(true);
                setError(error.response?.data?.message || "Export failed");
                setResponse(null);
            }
        });
    }
    ```

    **Add button** in the JSX ButtonGroup (after the Download Popover, around line 145, before the Tag Options section):

    ```jsx
    {results &&
        <Button icon="export" text="Export to epicTree"
            onClick={handleExportMat}
            intent="success" />
    }
    ```

    **Important details:**
    - Uses `responseType: 'blob'` because the endpoint returns a binary .mat file, not JSON
    - Error handling must parse blob back to text/JSON since axios blob responses don't auto-parse errors
    - Button uses BlueprintJS `intent="success"` (green) to visually distinguish from the existing Download button
    - Button uses `icon="export"` from BlueprintJS icon set
    - Only shown when `results` exist (same condition as Download button)
    - Snackbar shows success/error messages matching existing UX pattern
  </action>
  <verify>
    - ResultsViewer renders without errors
    - "Export to epicTree" button visible when query results are displayed
    - Button is styled consistently with other buttons in the ButtonGroup
  </verify>
  <done>
    "Export to epicTree" button appears in results panel. Clicking it triggers .mat export and downloads the file. Error messages display in the existing snackbar.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify end-to-end export in browser and MATLAB</name>
  <files></files>
  <action>
    Human verification of the complete export workflow.

    **What was built:** Flask /results/export-mat endpoint and "Export to epicTree" button in the DataJoint web UI.

    **How to verify:**
    1. Start the DataJoint app (Docker + Flask + Next.js)
    2. Connect to a database and run a query that returns patch clamp data
    3. In the results panel, verify the "Export to epicTree" button is visible (green button with export icon)
    4. Click "Export to epicTree" — browser should download a .mat file
    5. Verify .mat file is valid:
       ```matlab
       [data, meta] = loadEpicTreeData('path/to/downloaded.mat');
       tree = epicTreeTools(data, 'LoadUserMetadata', 'none');
       tree.buildTree({'cellInfo.type'});
       fprintf('Children: %d, Epochs: %d\n', tree.childrenLength(), tree.epochCount());
       ```
    6. (Optional) Test error case: run a query that returns MEA data and click export — should see error message in snackbar
  </action>
  <verify>User confirms the export works end-to-end from browser to MATLAB.</verify>
  <done>User types "approved" confirming the full DataJoint-to-epicTreeGUI export pipeline works.</done>
</task>

</tasks>

<verification>
- Flask app starts without errors
- /results/export-mat endpoint returns .mat file for valid query
- /results/export-mat returns 400 JSON error for no query, MEA data
- "Export to epicTree" button visible in results panel
- Clicking button downloads .mat file
- Snackbar shows success/error feedback
</verification>

<success_criteria>
- End-to-end: Query in DataJoint web UI -> click Export -> .mat downloads -> loads in MATLAB -> tree builds correctly
- Error path: MEA query -> click Export -> user-friendly error in snackbar
- No changes to epicTreeGUI MATLAB backend
</success_criteria>

<output>
After completion, create `.planning/phases/05-datajoint-integration-export-mat-from-datajoint-query-results/05-02-SUMMARY.md`
</output>
