---
phase: 00.1-critical-bug-fixes-selection-state
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tree/epicTreeTools.m
  - src/loadEpicTreeData.m
autonomous: true

must_haves:
  truths:
    - "User can deselect epochs and only selected epochs are returned for analysis"
    - "User can save selection state and it persists to a .ugm file"
    - "User can load a .ugm file and the saved selection state is restored"
    - "When multiple .ugm files exist, the most recent one is used by default"
    - "User can control .ugm loading behavior when creating a tree (auto/latest/none/specific file)"
  artifacts:
    - path: "src/tree/epicTreeTools.m"
      provides: "Selection bug fix, .ugm save/load/find methods, LoadUserMetadata constructor option, sourceFile property"
      contains: "saveUserMetadata, loadUserMetadata, findLatestUGM, sourceFile"
    - path: "src/loadEpicTreeData.m"
      provides: "Source file path stored in returned data struct"
      contains: "source_file"
  key_links:
    - from: "epicTreeTools.saveUserMetadata"
      to: ".ugm MAT file on disk"
      via: "MATLAB save() with ugm struct containing version, created, epoch_count, selection_mask, mat_file_basename"
    - from: "epicTreeTools.loadUserMetadata"
      to: "epicTreeTools.epochList{i}.isSelected"
      via: "Load .ugm file, validate epoch_count, apply logical mask to leaf epoch structs"
    - from: "epicTreeTools constructor"
      to: "epicTreeTools.loadUserMetadata"
      via: "Name-Value pair 'LoadUserMetadata' parsed by inputParser"
    - from: "loadEpicTreeData"
      to: "epicTreeTools constructor"
      via: "data.source_file field set by loadEpicTreeData, read by constructor to populate sourceFile property"
---

<objective>
Fix the core selection state bug (BUG-001), add .ugm file persistence, and extend the epicTreeTools constructor with LoadUserMetadata options.

Purpose: Selection filtering is the most critical feature in the analysis workflow. Without it, every analysis function processes ALL epochs instead of the user's chosen subset. The .ugm persistence system per user decision keeps selection state separate from raw experiment data (three-file architecture).

Output: Updated epicTreeTools.m with verified selection filtering, .ugm save/load/find methods, sourceFile property, LoadUserMetadata constructor option. Updated loadEpicTreeData.m to store source file path in returned data struct.
</objective>

<execution_context>
@/Users/maxwellsdm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/maxwellsdm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-CONTEXT.md
@.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-RESEARCH.md
@src/tree/epicTreeTools.m
@src/loadEpicTreeData.m
@BUGS_FOUND_PHASE0.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify selection filtering, add sourceFile property, and update loadEpicTreeData</name>
  <files>src/tree/epicTreeTools.m, src/loadEpicTreeData.m</files>
  <action>
**Part A: Verify the core selection bug fix**

Research found that `setSelected()` (line 984) and `getAllEpochs(true)` (line 943) already work correctly. The bug was in test code that directly modified returned epoch struct copies instead of using `setSelected()`. Verify by running the verification script below.

**IMPORTANT:** Do NOT refactor these methods to use a centralized selectionMask. Per research recommendation: "Keep per-epoch flags as primary source (already implemented, working). Build mask on-demand when saving .ugm. Avoid dual-storage to prevent sync issues."

**Contingency:** If the verification script reveals that `getAllEpochs(true)` does NOT filter correctly (contradicting research), add filtering logic to the `getAllEpochs` method. The leaf node branch should check `isfield(ep, 'isSelected') && ep.isSelected` for each epoch and only include those that pass. The internal node branch should recursively collect from children using the same `onlySelected` flag. See CONTEXT.md "Selection Methods Fix" section for the expected pattern.

**Part B: Add sourceFile property**

Add a new public property `sourceFile` to the properties block (around line 82-91). This stores the path to the .mat file used to create the tree, needed for .ugm file discovery.

```matlab
sourceFile = ''         % Path to source .mat file (for .ugm file discovery)
```

Add it after the `treeData` property.

**Part C: Update loadEpicTreeData to store source_file in returned data**

Modify `src/loadEpicTreeData.m` to store the filename in the returned `treeData` struct. After line 61 (`treeData.experiments = loaded.experiments;`), add:

```matlab
% Store source file path so epicTreeTools can discover .ugm files
treeData.source_file = filename;
```

This ensures that `epicTreeTools(data)` can automatically capture the source file path without requiring the user to set it manually.

**Part D: Set sourceFile from data.source_file in epicTreeTools constructor**

In the epicTreeTools constructor (line 106-128), in the `isstruct(dataOrParent)` branch, after the existing initialization code, add:

```matlab
% Capture source file path if available in data
if isfield(dataOrParent, 'source_file')
    obj.sourceFile = dataOrParent.source_file;
end
```

This connects loadEpicTreeData's output directly to the epicTreeTools sourceFile property, enabling automatic .ugm file discovery.
  </action>
  <verify>
Run in MATLAB using MCP:
```matlab
% Verify selection filtering works correctly
[data, ~] = loadEpicTreeData('/Users/maxwellsdm/Documents/epicTreeTest/analysis/2025-12-02_F.mat');
tree = epicTreeTools(data);
tree.buildTree({'cellInfo.type'});

% Verify source_file was captured
assert(~isempty(tree.sourceFile), 'sourceFile should be set from loadEpicTreeData');
assert(contains(tree.sourceFile, '2025-12-02_F.mat'), 'sourceFile should contain the filename');

% Get a leaf node
leaves = tree.leafNodes();
leaf = leaves{1};

% Count total
totalBefore = leaf.epochCount();

% Deselect using setSelected (correct method)
leaf.setSelected(false, true);

% Verify getAllEpochs(true) returns 0
selectedAfter = leaf.getAllEpochs(true);
assert(isempty(selectedAfter), 'getAllEpochs(true) should return empty after deselecting all');

% Re-select
leaf.setSelected(true, true);
selectedAll = leaf.getAllEpochs(true);
assert(length(selectedAll) == totalBefore, 'getAllEpochs(true) should return all after re-selecting');

% Verify sourceFile property exists
assert(isprop(tree, 'sourceFile'), 'sourceFile property should exist');

disp('Task 1 verification PASSED');
```
  </verify>
  <done>
- `setSelected(false, true)` on a leaf node causes `getAllEpochs(true)` to return 0 epochs
- `setSelected(true, true)` restores all epochs
- `sourceFile` property exists on epicTreeTools
- `loadEpicTreeData()` stores `source_file` in returned data struct
- epicTreeTools constructor reads `data.source_file` and sets `sourceFile` automatically
- No changes to the working `getAllEpochs()` or `setSelected()` filtering logic (unless verification reveals they need fixing)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add .ugm persistence methods (save/load/find/generate)</name>
  <files>src/tree/epicTreeTools.m</files>
  <action>
**Part A: Add saveUserMetadata() method**

Add a new public method `saveUserMetadata(obj, filepath)` to epicTreeTools. Place it after the `setSelected()` method (after line 1013).

Implementation:
- Build a `ugm` struct with fields: `version` ('1.0'), `created` (datetime('now')), `epoch_count` (length of allEpochs), `mat_file_basename` (extracted from sourceFile or filepath using `fileparts()`), `selection_mask` (logical array built by iterating allEpochs and checking isSelected)
- Use `save(filepath, 'ugm', '-v7.3')` to write the .ugm file
- Print confirmation: `fprintf('Saved selection mask (%d selected / %d total) to: %s\n', sum(ugm.selection_mask), ugm.epoch_count, filepath)`
- The method should work on the ROOT node (which has allEpochs). If called on a non-root node, get allEpochs by walking up to root first via `getRoot()`.

**Part B: Add loadUserMetadata() method**

Add a new public method `success = loadUserMetadata(obj, filepath)`.

Implementation:
- Check file exists, return false if not
- Try `load(filepath)`, catch errors and warn
- Validate struct has `selection_mask` and `epoch_count` fields
- Validate `ugm.epoch_count == length(obj.allEpochs)` - warn and return false if mismatch
- Apply mask: iterate allEpochs and set `isSelected` on each epoch struct
- **CRITICAL:** Must also propagate to leaf nodes. After applying to allEpochs, call `obj.refreshNodeSelectionState()` to sync `node.custom.isSelected` for each node in the tree based on actual epoch states.
- Return true on success

**Part C: Add refreshNodeSelectionState() method**

Add a public method that walks the tree and syncs `node.custom.isSelected` with the actual selection state of epochs under each node.

```matlab
function refreshNodeSelectionState(obj)
    if obj.isLeaf
        % Check if any epoch is selected
        anySelected = false;
        for i = 1:length(obj.epochList)
            if isfield(obj.epochList{i}, 'isSelected') && obj.epochList{i}.isSelected
                anySelected = true;
                break;
            end
        end
        obj.custom.isSelected = anySelected;
    else
        % Recurse to children
        anyChildSelected = false;
        for i = 1:length(obj.children)
            obj.children{i}.refreshNodeSelectionState();
            if obj.children{i}.custom.isSelected
                anyChildSelected = true;
            end
        end
        obj.custom.isSelected = anyChildSelected;
    end
end
```

**Part D: Add findLatestUGM() static method**

Add a static method `filepath = findLatestUGM(matFilePath)` in the static methods section.

Implementation:
- Extract directory and basename from matFilePath using `fileparts()`
- Use `dir(fullfile(directory, [basename '_*.ugm']))` to find matching files
- If empty, return ''
- Sort filenames descending (ISO 8601 timestamps sort lexicographically)
- Return `fullfile(directory, files(idx(1)).name)`

**Part E: Add generateUGMFilename() static method**

Add a static method `filepath = generateUGMFilename(matFilePath)`.
- Extract directory and basename from matFilePath
- Generate timestamp: `string(datetime('now'), 'uuuu-MM-dd_HH-mm-ss')`
- Return `fullfile(directory, sprintf('%s_%s.ugm', basename, timestamp))`
  </action>
  <verify>
Run in MATLAB using MCP:
```matlab
% Test save and load round-trip
[data, ~] = loadEpicTreeData('/Users/maxwellsdm/Documents/epicTreeTest/analysis/2025-12-02_F.mat');
tree = epicTreeTools(data, 'LoadUserMetadata', 'none');

% Deselect first child's epochs
tree.buildTree({'cellInfo.type'});
child = tree.childAt(1);
child.setSelected(false, true);

% Verify some deselected
allEp = tree.getAllEpochs(true);
totalEp = tree.getAllEpochs(false);
assert(length(allEp) < length(totalEp), 'Should have fewer selected than total');

% Save
ugmPath = epicTreeTools.generateUGMFilename(tree.sourceFile);
tree.saveUserMetadata(ugmPath);
assert(exist(ugmPath, 'file') == 2, '.ugm file should exist');

% Load into fresh tree
tree2 = epicTreeTools(data, 'LoadUserMetadata', 'none');
tree2.buildTree({'cellInfo.type'});
success = tree2.loadUserMetadata(ugmPath);
assert(success, 'loadUserMetadata should succeed');

% Verify same selection state
allEp2 = tree2.getAllEpochs(true);
assert(length(allEp2) == length(allEp), 'Selection should match after round-trip');

% Cleanup
delete(ugmPath);

% Test findLatestUGM
latestPath = epicTreeTools.findLatestUGM(tree.sourceFile);
assert(ischar(latestPath) || isstring(latestPath), 'findLatestUGM should return char/string');

disp('Task 2 verification PASSED');
```
  </verify>
  <done>
- `saveUserMetadata()` creates a .ugm MAT file with version, created, epoch_count, selection_mask, mat_file_basename fields
- `loadUserMetadata()` restores selection state from .ugm file with validation
- `refreshNodeSelectionState()` syncs node.custom.isSelected with actual epoch states
- `findLatestUGM()` finds the most recent .ugm file by filename sorting
- `generateUGMFilename()` creates timestamped .ugm filename
- Round-trip save/load preserves selection state
  </done>
</task>

<task type="auto">
  <name>Task 3: Add LoadUserMetadata constructor option</name>
  <files>src/tree/epicTreeTools.m</files>
  <action>
**Part A: Modify constructor to accept varargin**

Modify the constructor (line 106-128) to accept optional Name-Value pair arguments using `varargin` and `inputParser`.

Change signature from:
```matlab
function obj = epicTreeTools(dataOrParent)
```
to:
```matlab
function obj = epicTreeTools(dataOrParent, varargin)
```

**Part B: Add LoadUserMetadata option parsing**

Inside the `isstruct(dataOrParent)` branch (after the sourceFile capture from Task 1), add LoadUserMetadata handling:

```matlab
% Parse optional arguments
p = inputParser;
p.KeepUnmatched = true;  % Allow unknown params
addParameter(p, 'LoadUserMetadata', 'auto', @(x) ischar(x) || isstring(x));
parse(p, varargin{:});

loadOption = char(p.Results.LoadUserMetadata);

if strcmp(loadOption, 'auto')
    % Auto-load latest .ugm if exists (silent if none found)
    if ~isempty(obj.sourceFile)
        ugmFile = epicTreeTools.findLatestUGM(obj.sourceFile);
        if ~isempty(ugmFile)
            obj.loadUserMetadata(ugmFile);
        end
    end
elseif strcmp(loadOption, 'latest')
    % Load latest, error if none exists
    if isempty(obj.sourceFile)
        error('epicTreeTools:NoSourceFile', ...
            'Cannot find .ugm files: sourceFile not set. Set sourceFile property or pass data with source_file field.');
    end
    ugmFile = epicTreeTools.findLatestUGM(obj.sourceFile);
    if isempty(ugmFile)
        error('epicTreeTools:NoUGMFiles', ...
            'No .ugm files found for: %s', obj.sourceFile);
    end
    obj.loadUserMetadata(ugmFile);
elseif strcmp(loadOption, 'none')
    % Skip loading, all epochs selected by default (already the case)
else
    % Assume it's a filename path
    if ~obj.loadUserMetadata(loadOption)
        warning('epicTreeTools:UGMLoadFailed', ...
            'Failed to load user metadata from: %s', loadOption);
    end
end
```

IMPORTANT: The `isa(dataOrParent, 'epicTreeTools')` branch (child node creation) should NOT parse varargin for LoadUserMetadata. Only root nodes created from data structs get .ugm loading.
  </action>
  <verify>
Run in MATLAB using MCP:
```matlab
% Test constructor with 'none' option
[data, ~] = loadEpicTreeData('/Users/maxwellsdm/Documents/epicTreeTest/analysis/2025-12-02_F.mat');
tree = epicTreeTools(data, 'LoadUserMetadata', 'none');
assert(~isempty(tree.allEpochs), 'Tree should have epochs');
allSelected = tree.getAllEpochs(true);
allTotal = tree.getAllEpochs(false);
assert(length(allSelected) == length(allTotal), 'With none option, all epochs should be selected');

% Test constructor with default (auto) - should silently skip if no .ugm exists
tree2 = epicTreeTools(data);
assert(~isempty(tree2.allEpochs), 'Tree should have epochs with default constructor');

disp('Task 3 verification PASSED');
```
  </verify>
  <done>
- Constructor accepts 'LoadUserMetadata' option with 'auto', 'latest', 'none', or filename values
- 'auto' silently loads latest .ugm if one exists, otherwise all selected
- 'latest' errors if no .ugm files found
- 'none' skips loading entirely
- Explicit filename path loads that specific .ugm file
- Child node construction is unaffected by varargin
  </done>
</task>

</tasks>

<verification>
1. Selection filtering works: `setSelected(false, true)` then `getAllEpochs(true)` returns empty
2. `loadEpicTreeData()` returns data struct with `source_file` field containing the filename
3. `epicTreeTools(data)` auto-populates `sourceFile` from `data.source_file`
4. .ugm file round-trip: save selection, load into fresh tree, same selection state
5. Constructor option: `epicTreeTools(data, 'LoadUserMetadata', 'none')` creates tree without loading .ugm
6. No regression: existing `buildTree()` and `buildTreeWithSplitters()` still work unchanged
</verification>

<success_criteria>
- BUG-001 root cause confirmed and code verified correct (setSelected + getAllEpochs filtering)
- loadEpicTreeData provides source_file in returned data struct
- .ugm persistence system fully implemented in epicTreeTools
- Constructor supports LoadUserMetadata Name-Value option
- All verification commands pass without error
</success_criteria>

<output>
After completion, create `.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-01-SUMMARY.md`
</output>
