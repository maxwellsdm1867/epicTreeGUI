---
phase: 00.1-critical-bug-fixes-selection-state
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tree/epicTreeTools.m
  - src/loadEpicTreeData.m
autonomous: true

must_haves:
  truths:
    - "User can deselect epochs and only selected epochs are returned for analysis"
    - "User can save selection state and it persists to a .ugm file"
    - "User can load a .ugm file and the saved selection state is restored"
    - "When multiple .ugm files exist, the most recent one is used by default"
    - "User can control .ugm loading behavior when creating a tree (auto/latest/none/specific file)"
    - "System shows command window warnings when loading with mask"
  artifacts:
    - path: "src/tree/epicTreeTools.m"
      provides: "Selection bug fix, .ugm save/load/find methods, LoadUserMetadata constructor option, sourceFile property"
      contains: "saveUserMetadata, loadUserMetadata, findLatestUGM, sourceFile"
    - path: "src/loadEpicTreeData.m"
      provides: "Source file path stored in returned data struct"
      contains: "source_file"
  key_links:
    - from: "epicTreeTools.saveUserMetadata"
      to: ".ugm MAT file on disk"
      via: "Build mask from isSelected flags (one-time on save), save to .ugm with version, created, epoch_count, selection_mask, mat_file_basename"
    - from: "epicTreeTools.loadUserMetadata"
      to: "epicTreeTools.epochList{i}.isSelected"
      via: "Load .ugm file, validate epoch_count, copy mask to epoch isSelected flags (one-time on load)"
    - from: "epicTreeTools constructor"
      to: "epicTreeTools.loadUserMetadata"
      via: "Name-Value pair 'LoadUserMetadata' parsed by inputParser"
    - from: "loadEpicTreeData"
      to: "epicTreeTools constructor"
      via: "data.source_file field set by loadEpicTreeData, read by constructor to populate sourceFile property"
---

<objective>
Fix the core selection state bug (BUG-001), add .ugm file persistence, and extend the epicTreeTools constructor with LoadUserMetadata options.

Purpose: Selection filtering is the most critical feature in the analysis workflow. Without it, every analysis function processes ALL epochs instead of the user's chosen subset. The .ugm persistence system per user decision keeps selection state separate from raw experiment data (three-file architecture).

**Simplified Architecture:** isSelected flags on epochs are the source of truth during work. Mask is built only when saving (one-time operation). On load, mask is copied to isSelected flags (one-time operation). No centralized selectionMask property. No real-time sync overhead.

Output: Updated epicTreeTools.m with verified selection filtering, .ugm save/load/find methods, sourceFile property, LoadUserMetadata constructor option, command window warnings. Updated loadEpicTreeData.m to store source file path in returned data struct.
</objective>

<execution_context>
@/Users/maxwellsdm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/maxwellsdm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-CONTEXT.md
@.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-RESEARCH.md
@src/tree/epicTreeTools.m
@src/loadEpicTreeData.m
@BUGS_FOUND_PHASE0.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify selection filtering, add sourceFile property, and update loadEpicTreeData</name>
  <files>src/tree/epicTreeTools.m, src/loadEpicTreeData.m</files>
  <action>
**Part A: Verify the core selection bug fix**

Research found that `setSelected()` (line 984) and `getAllEpochs(true)` (line 943) already work correctly. The bug was in test code that directly modified returned epoch struct copies instead of using `setSelected()`. Verify by running the verification script below.

**IMPORTANT:** Do NOT refactor these methods to use a centralized selectionMask. Per simplified architecture: isSelected flag on each epoch = source of truth during session. Build mask only on save (one-time). No sync overhead.

**Contingency:** If the verification script reveals that `getAllEpochs(true)` does NOT filter correctly (contradicting research), add filtering logic to the `getAllEpochs` method. The leaf node branch should check `isfield(ep, 'isSelected') && ep.isSelected` for each epoch and only include those that pass. The internal node branch should recursively collect from children using the same `onlySelected` flag. See CONTEXT.md "Selection Methods Fix" section for the expected pattern.

**Part B: Add sourceFile property**

Add a new public property `sourceFile` to the properties block (around line 82-91). This stores the path to the .mat file used to create the tree, needed for .ugm file discovery.

```matlab
sourceFile = ''         % Path to source .mat file (for .ugm file discovery)
```

Add it after the `treeData` property.

**Part C: Update loadEpicTreeData to store source_file in returned data**

Modify `src/loadEpicTreeData.m` to store the filename in the returned `treeData` struct. After line 61 (`treeData.experiments = loaded.experiments;`), add:

```matlab
% Store source file path so epicTreeTools can discover .ugm files
treeData.source_file = filename;
```

This ensures that `epicTreeTools(data)` can automatically capture the source file path without requiring the user to set it manually.

**Part D: Set sourceFile from data.source_file in epicTreeTools constructor**

In the epicTreeTools constructor (line 106-128), in the `isstruct(dataOrParent)` branch, after the existing initialization code, add:

```matlab
% Capture source file path if available in data
if isfield(dataOrParent, 'source_file')
    obj.sourceFile = dataOrParent.source_file;
end
```

This connects loadEpicTreeData's output directly to the epicTreeTools sourceFile property, enabling automatic .ugm file discovery.
  </action>
  <verify>
Run in MATLAB using MCP:
```matlab
% Verify selection filtering works correctly
[data, ~] = loadEpicTreeData('/Users/maxwellsdm/Documents/epicTreeTest/analysis/2025-12-02_F.mat');
tree = epicTreeTools(data);
tree.buildTree({'cellInfo.type'});

% Verify source_file was captured
assert(~isempty(tree.sourceFile), 'sourceFile should be set from loadEpicTreeData');
assert(contains(tree.sourceFile, '2025-12-02_F.mat'), 'sourceFile should contain the filename');

% Get a leaf node
leaves = tree.leafNodes();
leaf = leaves{1};

% Count total
totalBefore = leaf.epochCount();

% Deselect using setSelected (correct method)
leaf.setSelected(false, true);

% Verify getAllEpochs(true) returns 0
selectedAfter = leaf.getAllEpochs(true);
assert(isempty(selectedAfter), 'getAllEpochs(true) should return empty after deselecting all');

% Re-select
leaf.setSelected(true, true);
selectedAll = leaf.getAllEpochs(true);
assert(length(selectedAll) == totalBefore, 'getAllEpochs(true) should return all after re-selecting');

% Verify sourceFile property exists
assert(isprop(tree, 'sourceFile'), 'sourceFile property should exist');

disp('Task 1 verification PASSED');
```
  </verify>
  <done>
- `setSelected(false, true)` on a leaf node causes `getAllEpochs(true)` to return 0 epochs
- `setSelected(true, true)` restores all epochs
- `sourceFile` property exists on epicTreeTools
- `loadEpicTreeData()` stores `source_file` in returned data struct
- epicTreeTools constructor reads `data.source_file` and sets `sourceFile` automatically
- No changes to the working `getAllEpochs()` or `setSelected()` filtering logic (unless verification reveals they need fixing)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add .ugm persistence methods (save/load/find/generate) with one-time mask building</name>
  <files>src/tree/epicTreeTools.m</files>
  <action>
**Part A: Add saveUserMetadata() method with one-time mask building**

Add a new public method `saveUserMetadata(obj, filepath)` to epicTreeTools. Place it after the `setSelected()` method (after line 1013).

Implementation:
- Get all epochs using `obj.getAllEpochs(false)` (works on root or any node)
- **Build mask from isSelected flags (ONE-TIME on save):**
  ```matlab
  allEps = obj.getAllEpochs(false);
  mask = false(length(allEps), 1);
  for i = 1:length(allEps)
      if isfield(allEps{i}, 'isSelected') && allEps{i}.isSelected
          mask(i) = true;
      end
  end
  ```
- Build a `ugm` struct with fields: `version` ('1.0'), `created` (datetime('now')), `epoch_count` (length(allEps)), `mat_file_basename` (extracted from sourceFile or filepath using `fileparts()`), `selection_mask` (the mask just built)
- Use `save(filepath, 'ugm', '-v7.3')` to write the .ugm file
- **Print command window message:** `fprintf('Saved selection mask to: %s\n  %d of %d epochs selected (%.1f%%)\n', filepath, sum(mask), length(mask), 100*sum(mask)/length(mask))`
- The method should work on any node (walks up to root if needed via `getRoot()` to get all epochs)

**Part B: Add loadUserMetadata() method with command window warnings**

Add a new public method `success = loadUserMetadata(obj, filepath)`.

Implementation:
- Check file exists, return false if not
- Try `load(filepath)`, catch errors and warn
- Validate struct has `selection_mask` and `epoch_count` fields
- Validate `ugm.epoch_count == length(obj.getAllEpochs(false))` - warn and return false if mismatch
- **Copy mask to isSelected flags (ONE-TIME on load):**
  ```matlab
  allEps = obj.getAllEpochs(false);
  for i = 1:length(allEps)
      if i <= length(ugm.selection_mask)
          allEps{i}.isSelected = ugm.selection_mask(i);
      else
          allEps{i}.isSelected = true;  % Default for new epochs
      end
  end
  ```
- **Print command window warning:**
  ```matlab
  excluded = ugm.epoch_count - sum(ugm.selection_mask);
  fprintf('Selection mask loaded: %s\n  %d of %d epochs excluded (%.1f%%)\n', ...
      filepath, excluded, ugm.epoch_count, 100*excluded/ugm.epoch_count);
  ```
- **CRITICAL:** Must also propagate to node cache. After applying to epochs, call `obj.refreshNodeSelectionState()` to sync `node.custom.isSelected` for each node in the tree based on actual epoch states.
- Return true on success

**Part C: Add refreshNodeSelectionState() method**

Add a public method that walks the tree and syncs `node.custom.isSelected` with the actual selection state of epochs under each node.

```matlab
function refreshNodeSelectionState(obj)
    if obj.isLeaf
        % Check if any epoch is selected
        anySelected = false;
        for i = 1:length(obj.epochList)
            if isfield(obj.epochList{i}, 'isSelected') && obj.epochList{i}.isSelected
                anySelected = true;
                break;
            end
        end
        obj.custom.isSelected = anySelected;
    else
        % Recurse to children
        anyChildSelected = false;
        for i = 1:length(obj.children)
            obj.children{i}.refreshNodeSelectionState();
            if obj.children{i}.custom.isSelected
                anyChildSelected = true;
            end
        end
        obj.custom.isSelected = anyChildSelected;
    end
end
```

**Part D: Add findLatestUGM() static method**

Add a static method `filepath = findLatestUGM(matFilePath)` in the static methods section.

Implementation:
- Extract directory and basename from matFilePath using `fileparts()`
- Use `dir(fullfile(directory, [basename '_*.ugm']))` to find matching files
- If empty, return ''
- Sort filenames descending (ISO 8601 timestamps sort lexicographically)
- Return `fullfile(directory, files(idx(1)).name)`

**Part E: Add generateUGMFilename() static method**

Add a static method `filepath = generateUGMFilename(matFilePath)`.
- Extract directory and basename from matFilePath
- Generate timestamp: `string(datetime('now'), 'uuuu-MM-dd_HH-mm-ss')`
- Return `fullfile(directory, sprintf('%s_%s.ugm', basename, timestamp))`
  </action>
  <verify>
Run in MATLAB using MCP:
```matlab
% Test save and load round-trip
[data, ~] = loadEpicTreeData('/Users/maxwellsdm/Documents/epicTreeTest/analysis/2025-12-02_F.mat');
tree = epicTreeTools(data, 'LoadUserMetadata', 'none');

% Deselect first child's epochs
tree.buildTree({'cellInfo.type'});
child = tree.childAt(1);
child.setSelected(false, true);

% Verify some deselected
allEp = tree.getAllEpochs(true);
totalEp = tree.getAllEpochs(false);
assert(length(allEp) < length(totalEp), 'Should have fewer selected than total');

% Save (should print command window message)
ugmPath = epicTreeTools.generateUGMFilename(tree.sourceFile);
tree.saveUserMetadata(ugmPath);
assert(exist(ugmPath, 'file') == 2, '.ugm file should exist');

% Load into fresh tree (should print command window warning)
tree2 = epicTreeTools(data, 'LoadUserMetadata', 'none');
tree2.buildTree({'cellInfo.type'});
success = tree2.loadUserMetadata(ugmPath);
assert(success, 'loadUserMetadata should succeed');

% Verify same selection state
allEp2 = tree2.getAllEpochs(true);
assert(length(allEp2) == length(allEp), 'Selection should match after round-trip');

% Cleanup
delete(ugmPath);

% Test findLatestUGM
latestPath = epicTreeTools.findLatestUGM(tree.sourceFile);
assert(ischar(latestPath) || isstring(latestPath), 'findLatestUGM should return char/string');

disp('Task 2 verification PASSED');
```
  </verify>
  <done>
- `saveUserMetadata()` builds mask from isSelected flags ONE-TIME when saving
- `saveUserMetadata()` prints command window message showing selection count
- `loadUserMetadata()` copies mask to isSelected flags ONE-TIME when loading
- `loadUserMetadata()` prints command window warning showing excluded count
- `refreshNodeSelectionState()` syncs node.custom.isSelected with actual epoch states
- `findLatestUGM()` finds the most recent .ugm file by filename sorting
- `generateUGMFilename()` creates timestamped .ugm filename
- Round-trip save/load preserves selection state
- No centralized selectionMask property (simplified architecture)
  </done>
</task>

<task type="auto">
  <name>Task 3: Add LoadUserMetadata constructor option with command window warnings</name>
  <files>src/tree/epicTreeTools.m</files>
  <action>
**Part A: Modify constructor to accept varargin**

Modify the constructor (line 106-128) to accept optional Name-Value pair arguments using `varargin` and `inputParser`.

Change signature from:
```matlab
function obj = epicTreeTools(dataOrParent)
```
to:
```matlab
function obj = epicTreeTools(dataOrParent, varargin)
```

**Part B: Add LoadUserMetadata option parsing with command window output**

Inside the `isstruct(dataOrParent)` branch (after the sourceFile capture from Task 1), add LoadUserMetadata handling:

```matlab
% Parse optional arguments
p = inputParser;
p.KeepUnmatched = true;  % Allow unknown params
addParameter(p, 'LoadUserMetadata', 'auto', @(x) ischar(x) || isstring(x));
parse(p, varargin{:});

loadOption = char(p.Results.LoadUserMetadata);

if strcmp(loadOption, 'auto')
    % Auto-load latest .ugm if exists (silent if none found)
    if ~isempty(obj.sourceFile)
        ugmFile = epicTreeTools.findLatestUGM(obj.sourceFile);
        if ~isempty(ugmFile)
            fprintf('Auto-loading selection mask: %s\n', ugmFile);
            obj.loadUserMetadata(ugmFile);  % This prints its own warning
        end
    end
elseif strcmp(loadOption, 'latest')
    % Load latest, error if none exists
    if isempty(obj.sourceFile)
        error('epicTreeTools:NoSourceFile', ...
            'Cannot find .ugm files: sourceFile not set. Set sourceFile property or pass data with source_file field.');
    end
    ugmFile = epicTreeTools.findLatestUGM(obj.sourceFile);
    if isempty(ugmFile)
        error('epicTreeTools:NoUGMFiles', ...
            'No .ugm files found for: %s', obj.sourceFile);
    end
    obj.loadUserMetadata(ugmFile);
elseif strcmp(loadOption, 'none')
    % Skip loading, all epochs selected by default (already the case)
else
    % Assume it's a filename path
    if ~obj.loadUserMetadata(loadOption)
        warning('epicTreeTools:UGMLoadFailed', ...
            'Failed to load user metadata from: %s', loadOption);
    end
end
```

IMPORTANT: The `isa(dataOrParent, 'epicTreeTools')` branch (child node creation) should NOT parse varargin for LoadUserMetadata. Only root nodes created from data structs get .ugm loading.
  </action>
  <verify>
Run in MATLAB using MCP:
```matlab
% Test constructor with 'none' option (should not print auto-loading message)
[data, ~] = loadEpicTreeData('/Users/maxwellsdm/Documents/epicTreeTest/analysis/2025-12-02_F.mat');
tree = epicTreeTools(data, 'LoadUserMetadata', 'none');
assert(~isempty(tree.allEpochs), 'Tree should have epochs');
allSelected = tree.getAllEpochs(true);
allTotal = tree.getAllEpochs(false);
assert(length(allSelected) == length(allTotal), 'With none option, all epochs should be selected');

% Test constructor with default (auto) - should print auto-loading message if .ugm exists
tree2 = epicTreeTools(data);
assert(~isempty(tree2.allEpochs), 'Tree should have epochs with default constructor');

disp('Task 3 verification PASSED');
```
  </verify>
  <done>
- Constructor accepts 'LoadUserMetadata' option with 'auto', 'latest', 'none', or filename values
- 'auto' prints "Auto-loading selection mask: ..." when .ugm file found
- 'auto' silently skips if no .ugm exists (all selected)
- 'latest' errors if no .ugm files found
- 'none' skips loading entirely (no messages)
- Explicit filename path loads that specific .ugm file
- loadUserMetadata() prints command window warning showing excluded epoch count
- Child node construction is unaffected by varargin
  </done>
</task>

</tasks>

<verification>
1. Selection filtering works: `setSelected(false, true)` then `getAllEpochs(true)` returns empty
2. `loadEpicTreeData()` returns data struct with `source_file` field containing the filename
3. `epicTreeTools(data)` auto-populates `sourceFile` from `data.source_file`
4. .ugm file round-trip: save selection, load into fresh tree, same selection state
5. Constructor option: `epicTreeTools(data, 'LoadUserMetadata', 'none')` creates tree without loading .ugm
6. Command window messages: save shows selection count, load shows excluded count
7. Auto-load prints "Auto-loading selection mask: ..." when .ugm found
8. No regression: existing `buildTree()` and `buildTreeWithSplitters()` still work unchanged
9. No centralized selectionMask property (simplified architecture)
</verification>

<success_criteria>
- BUG-001 root cause confirmed and code verified correct (setSelected + getAllEpochs filtering)
- loadEpicTreeData provides source_file in returned data struct
- .ugm persistence system fully implemented in epicTreeTools with simplified architecture (build mask on save only)
- Constructor supports LoadUserMetadata Name-Value option
- Command window warnings show epoch counts when loading/saving masks
- All verification commands pass without error
</success_criteria>

<output>
After completion, create `.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-01-SUMMARY.md`
</output>
