---
phase: 00.1-critical-bug-fixes-selection-state
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tree/epicTreeTools.m
autonomous: true

must_haves:
  truths:
    - "setSelected(false, true) on a node causes getAllEpochs(true) to return fewer epochs"
    - "saveUserMetadata() creates a .ugm file with correct selection mask"
    - "loadUserMetadata() restores selection state from .ugm file"
    - "findLatestUGM() returns the most recent .ugm file by timestamp"
    - "Constructor with 'LoadUserMetadata' option controls .ugm loading behavior"
  artifacts:
    - path: "src/tree/epicTreeTools.m"
      provides: "Selection bug fix, .ugm save/load/find methods, LoadUserMetadata constructor option, sourceFile property"
      contains: "saveUserMetadata, loadUserMetadata, findLatestUGM, sourceFile"
  key_links:
    - from: "epicTreeTools.saveUserMetadata"
      to: ".ugm MAT file on disk"
      via: "MATLAB save() with ugm struct containing version, created, epoch_count, selection_mask, mat_file_basename"
    - from: "epicTreeTools.loadUserMetadata"
      to: "epicTreeTools.epochList{i}.isSelected"
      via: "Load .ugm file, validate epoch_count, apply logical mask to leaf epoch structs"
    - from: "epicTreeTools constructor"
      to: "epicTreeTools.loadUserMetadata"
      via: "Name-Value pair 'LoadUserMetadata' parsed by inputParser"
---

<objective>
Fix the core selection state bug (BUG-001), add .ugm file persistence, and extend the epicTreeTools constructor with LoadUserMetadata options.

Purpose: Selection filtering is the most critical feature in the analysis workflow. Without it, every analysis function processes ALL epochs instead of the user's chosen subset. The .ugm persistence system per user decision keeps selection state separate from raw experiment data (three-file architecture).

Output: Updated epicTreeTools.m with verified selection filtering, .ugm save/load/find methods, sourceFile property, and LoadUserMetadata constructor option.
</objective>

<execution_context>
@/Users/maxwellsdm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/maxwellsdm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-CONTEXT.md
@.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-RESEARCH.md
@src/tree/epicTreeTools.m
@BUGS_FOUND_PHASE0.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify selection filtering and add sourceFile property</name>
  <files>src/tree/epicTreeTools.m</files>
  <action>
**Part A: Verify the core selection bug fix**

The research found that `setSelected()` (line 984) and `getAllEpochs(true)` (line 943) already work correctly. The bug in the test was directly modifying returned epoch struct copies instead of using `setSelected()`. Verify this by:

1. Read `setSelected()` method (line 984-1013) - it directly modifies `obj.epochList{i}.isSelected` which updates the stored reference.
2. Read `getAllEpochs(true)` method (line 943-982) - it checks `isfield(ep, 'isSelected') && ep.isSelected` on leaf node's `epochList`.
3. Confirm: These two methods together should work. The filtering logic IS correct. The bug was in test code that bypassed `setSelected()`.

**IMPORTANT:** Do NOT refactor these methods to use a centralized selectionMask. Per research open question recommendation: "Keep per-epoch flags as primary source (already implemented, working). Build mask on-demand when saving .ugm. Avoid dual-storage to prevent sync issues."

**Part B: Add sourceFile property**

Add a new public property `sourceFile` to the properties block (around line 82-91). This stores the path to the .mat file used to create the tree, needed for .ugm file discovery.

```matlab
sourceFile = ''         % Path to source .mat file (for .ugm file discovery)
```

Add it after the `treeData` property.

**Part C: Set sourceFile in constructor**

In the constructor (line 106-128), the `dataOrParent` struct path is not available because `loadEpicTreeData()` strips it. The sourceFile needs to be set externally after construction OR passed in. Since the user's locked decision shows:

```matlab
tree = epicTreeTools(data);
```

The simplest approach: let users set `tree.sourceFile = '/path/to/file.mat'` after construction. The GUI will set it automatically. Do NOT change the constructor signature for this - the `LoadUserMetadata` option (Task 2) handles the optional behavior.

However, also add a convenience: if `loadEpicTreeData()` stores the filename in the data struct (check if `dataOrParent` has a path field), use it. In the constructor's `isstruct(dataOrParent)` branch, after line 126, add:

```matlab
% Try to capture source file path if available in data
if isfield(dataOrParent, 'source_file')
    obj.sourceFile = dataOrParent.source_file;
end
```
  </action>
  <verify>
Run in MATLAB using MCP:
```matlab
% Verify selection filtering works correctly
[data, ~] = loadEpicTreeData('/Users/maxwellsdm/Documents/epicTreeTest/analysis/2025-12-02_F.mat');
tree = epicTreeTools(data);
tree.buildTree({'cellInfo.type'});

% Get a leaf node
leaves = tree.leafNodes();
leaf = leaves{1};

% Count total
totalBefore = leaf.epochCount();

% Deselect using setSelected (correct method)
leaf.setSelected(false, true);

% Verify getAllEpochs(true) returns 0
selectedAfter = leaf.getAllEpochs(true);
assert(isempty(selectedAfter), 'getAllEpochs(true) should return empty after deselecting all');

% Re-select
leaf.setSelected(true, true);
selectedAll = leaf.getAllEpochs(true);
assert(length(selectedAll) == totalBefore, 'getAllEpochs(true) should return all after re-selecting');

% Verify sourceFile property exists
assert(isprop(tree, 'sourceFile'), 'sourceFile property should exist');

disp('Task 1 verification PASSED');
```
  </verify>
  <done>
- `setSelected(false, true)` on a leaf node causes `getAllEpochs(true)` to return 0 epochs
- `setSelected(true, true)` restores all epochs
- `sourceFile` property exists on epicTreeTools
- No changes to the working `getAllEpochs()` or `setSelected()` filtering logic
  </done>
</task>

<task type="auto">
  <name>Task 2: Add .ugm save/load/find methods and LoadUserMetadata constructor option</name>
  <files>src/tree/epicTreeTools.m</files>
  <action>
**Part A: Add saveUserMetadata() method**

Add a new public method `saveUserMetadata(obj, filepath)` to epicTreeTools. Place it after the `setSelected()` method (after line 1013).

Implementation per research Example 3:
- Build a `ugm` struct with fields: `version` ('1.0'), `created` (datetime('now')), `epoch_count` (length of allEpochs), `mat_file_basename` (extracted from sourceFile or filepath), `selection_mask` (logical array built by iterating allEpochs and checking isSelected)
- Use `save(filepath, 'ugm', '-v7.3')` to write the .ugm file
- Print confirmation: `fprintf('Saved selection mask (%d selected / %d total) to: %s\n', sum(ugm.selection_mask), ugm.epoch_count, filepath)`
- The method should work on the ROOT node (which has allEpochs). If called on a non-root node, get allEpochs by walking up to root first via `getRoot()`.

**Part B: Add loadUserMetadata() method**

Add a new public method `success = loadUserMetadata(obj, filepath)`.

Implementation per research Example 4:
- Check file exists, return false if not
- Try `load(filepath)`, catch errors and warn
- Validate struct has `selection_mask` and `epoch_count` fields
- Validate `ugm.epoch_count == length(obj.allEpochs)` - warn and return false if mismatch
- Apply mask: iterate allEpochs and set `isSelected` on each epoch struct
- **CRITICAL:** Must also propagate to leaf nodes. After applying to allEpochs, call a helper that walks the tree and updates `epochList` items AND `node.custom.isSelected` for each node. The simplest way: since allEpochs and leaf epochList items are the SAME structs (cell array references), updating allEpochs IS updating epochList. But we still need to update `node.custom.isSelected` based on whether any of a node's epochs are selected. Add a helper `refreshNodeSelectionState(obj)` that:
  - For leaf nodes: set `obj.custom.isSelected` to true if any epoch is selected
  - For internal nodes: recurse to children, then set `obj.custom.isSelected` to true if any child is selected
- Call `obj.refreshNodeSelectionState()` after applying the mask
- Return true on success

**Part C: Add findLatestUGM() static method**

Add a static method `filepath = findLatestUGM(matFilePath)` in the static methods section.

Implementation per research Example 5:
- Extract directory and basename from matFilePath using `fileparts()`
- Use `dir(fullfile(directory, [basename '_*.ugm']))` to find matching files
- If empty, return ''
- Sort filenames descending (ISO 8601 timestamps sort lexicographically)
- Return `fullfile(directory, files(idx(1)).name)`

**Part D: Add generateUGMFilename() static method**

Add a static method `filepath = generateUGMFilename(matFilePath)`.
- Extract directory and basename from matFilePath
- Generate timestamp: `string(datetime('now'), 'uuuu-MM-dd_HH-mm-ss')`
- Return `fullfile(directory, sprintf('%s_%s.ugm', basename, timestamp))`

**Part E: Add refreshNodeSelectionState() method**

Add a private or public method that walks the tree and syncs `node.custom.isSelected` with the actual selection state of epochs under each node.

```matlab
function refreshNodeSelectionState(obj)
    if obj.isLeaf
        % Check if any epoch is selected
        anySelected = false;
        for i = 1:length(obj.epochList)
            if isfield(obj.epochList{i}, 'isSelected') && obj.epochList{i}.isSelected
                anySelected = true;
                break;
            end
        end
        obj.custom.isSelected = anySelected;
    else
        % Recurse to children
        anyChildSelected = false;
        for i = 1:length(obj.children)
            obj.children{i}.refreshNodeSelectionState();
            if obj.children{i}.custom.isSelected
                anyChildSelected = true;
            end
        end
        obj.custom.isSelected = anyChildSelected;
    end
end
```

**Part F: Add LoadUserMetadata constructor option**

Modify the constructor (line 106-128) to accept optional Name-Value pair arguments using `varargin` and `inputParser`.

Change signature from:
```matlab
function obj = epicTreeTools(dataOrParent)
```
to:
```matlab
function obj = epicTreeTools(dataOrParent, varargin)
```

Inside the `isstruct(dataOrParent)` branch (after line 126), add LoadUserMetadata handling:

```matlab
% Parse optional arguments
p = inputParser;
p.KeepUnmatched = true;  % Allow unknown params
addParameter(p, 'LoadUserMetadata', 'auto', @(x) ischar(x) || isstring(x));
parse(p, varargin{:});

loadOption = char(p.Results.LoadUserMetadata);

if strcmp(loadOption, 'auto')
    % Auto-load latest .ugm if exists (silent if none found)
    if ~isempty(obj.sourceFile)
        ugmFile = epicTreeTools.findLatestUGM(obj.sourceFile);
        if ~isempty(ugmFile)
            obj.loadUserMetadata(ugmFile);
        end
    end
elseif strcmp(loadOption, 'latest')
    % Load latest, error if none exists
    if isempty(obj.sourceFile)
        error('epicTreeTools:NoSourceFile', ...
            'Cannot find .ugm files: sourceFile not set. Set sourceFile property or pass data with source_file field.');
    end
    ugmFile = epicTreeTools.findLatestUGM(obj.sourceFile);
    if isempty(ugmFile)
        error('epicTreeTools:NoUGMFiles', ...
            'No .ugm files found for: %s', obj.sourceFile);
    end
    obj.loadUserMetadata(ugmFile);
elseif strcmp(loadOption, 'none')
    % Skip loading, all epochs selected by default (already the case)
else
    % Assume it's a filename path
    if ~obj.loadUserMetadata(loadOption)
        warning('epicTreeTools:UGMLoadFailed', ...
            'Failed to load user metadata from: %s', loadOption);
    end
end
```

IMPORTANT: The `isa(dataOrParent, 'epicTreeTools')` branch (child node creation) should NOT parse varargin for LoadUserMetadata. Only root nodes created from data structs get .ugm loading.
  </action>
  <verify>
Run in MATLAB using MCP:
```matlab
% Test save and load round-trip
[data, ~] = loadEpicTreeData('/Users/maxwellsdm/Documents/epicTreeTest/analysis/2025-12-02_F.mat');
tree = epicTreeTools(data, 'LoadUserMetadata', 'none');
tree.sourceFile = '/Users/maxwellsdm/Documents/epicTreeTest/analysis/2025-12-02_F.mat';

% Deselect first child's epochs
child = tree.childAt(1);
child.setSelected(false, true);

% Verify some deselected
allEp = tree.getAllEpochs(true);
totalEp = tree.getAllEpochs(false);
assert(length(allEp) < length(totalEp), 'Should have fewer selected than total');

% Save
ugmPath = epicTreeTools.generateUGMFilename(tree.sourceFile);
tree.saveUserMetadata(ugmPath);
assert(exist(ugmPath, 'file') == 2, '.ugm file should exist');

% Load into fresh tree
tree2 = epicTreeTools(data, 'LoadUserMetadata', 'none');
tree2.sourceFile = tree.sourceFile;
tree2.buildTree({'cellInfo.type'});
success = tree2.loadUserMetadata(ugmPath);
assert(success, 'loadUserMetadata should succeed');

% Verify same selection state
allEp2 = tree2.getAllEpochs(true);
assert(length(allEp2) == length(allEp), 'Selection should match after round-trip');

% Cleanup
delete(ugmPath);

% Test findLatestUGM
latestPath = epicTreeTools.findLatestUGM(tree.sourceFile);
assert(ischar(latestPath) || isstring(latestPath), 'findLatestUGM should return char/string');

disp('Task 2 verification PASSED');
```
  </verify>
  <done>
- `saveUserMetadata()` creates a .ugm MAT file with version, created, epoch_count, selection_mask, mat_file_basename fields
- `loadUserMetadata()` restores selection state from .ugm file with validation
- `findLatestUGM()` finds the most recent .ugm file by filename sorting
- `generateUGMFilename()` creates timestamped .ugm filename
- `refreshNodeSelectionState()` syncs node.custom.isSelected with actual epoch states
- Constructor accepts 'LoadUserMetadata' option with 'auto', 'latest', 'none', or filename values
- Round-trip save/load preserves selection state
  </done>
</task>

</tasks>

<verification>
1. Selection filtering works: `setSelected(false, true)` then `getAllEpochs(true)` returns empty
2. .ugm file round-trip: save selection, load into fresh tree, same selection state
3. Constructor option: `epicTreeTools(data, 'LoadUserMetadata', 'none')` creates tree without loading .ugm
4. No regression: existing `buildTree()` and `buildTreeWithSplitters()` still work unchanged
</verification>

<success_criteria>
- BUG-001 root cause confirmed and code verified correct (setSelected + getAllEpochs filtering)
- .ugm persistence system fully implemented in epicTreeTools
- Constructor supports LoadUserMetadata Name-Value option
- All verification commands pass without error
</success_criteria>

<output>
After completion, create `.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-01-SUMMARY.md`
</output>
