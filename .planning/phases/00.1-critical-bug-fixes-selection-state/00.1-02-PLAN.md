---
phase: 00.1-critical-bug-fixes-selection-state
plan: 02
type: execute
wave: 2
depends_on: ["00.1-01"]
files_modified:
  - epicTreeGUI.m
autonomous: true

must_haves:
  truths:
    - "GUI has a 'Save Epoch Mask' button in the File menu"
    - "Clicking 'Save Epoch Mask' saves current selection state to a .ugm file"
    - "If .ugm files already exist, user is prompted to replace latest or create new"
    - "GUI stores matFilePath so .ugm files can be discovered in the same directory"
    - "GUI has a close handler that compares current selection to loaded mask"
    - "On close, if selection changed, user is prompted to update mask"
  artifacts:
    - path: "epicTreeGUI.m"
      provides: "Save Epoch Mask menu item, matFilePath property, onSaveEpochMask callback, close handler with compare/prompt"
      contains: "Save Epoch Mask, onSaveEpochMask, matFilePath, onClose, loadedMask"
  key_links:
    - from: "epicTreeGUI.onSaveEpochMask"
      to: "epicTreeTools.saveUserMetadata"
      via: "Builds .ugm filepath, calls tree.saveUserMetadata(filepath)"
    - from: "epicTreeGUI.onSaveEpochMask"
      to: "epicTreeTools.findLatestUGM"
      via: "Checks for existing .ugm files to offer replace/create choice"
    - from: "epicTreeGUI.onClose"
      to: "epicTreeTools.saveUserMetadata"
      via: "Builds current mask from isSelected, compares to loadedMask, prompts user, saves if requested"
---

<objective>
Add "Save Epoch Mask" functionality to the GUI and implement close handler with mask comparison and save prompt.

Purpose: Per the user's locked decision, selection state should be manually saved via a GUI button labeled "Save Epoch Mask". The close handler implements the simplified architecture: build mask from isSelected on close (one-time), compare to loaded mask, prompt "Update mask with session changes?", save if yes.

Output: Updated epicTreeGUI.m with Save Epoch Mask menu item, matFilePath property, save callback with replace/create dialog, and close handler with compare/prompt workflow.
</objective>

<execution_context>
@/Users/maxwellsdm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/maxwellsdm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-CONTEXT.md
@.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-RESEARCH.md
@.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-01-SUMMARY.md
@epicTreeGUI.m
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add matFilePath and loadedMask properties, wire from constructor</name>
  <files>epicTreeGUI.m</files>
  <action>
**Part A: Add matFilePath and loadedMask properties**

In the properties block of epicTreeGUI.m (around line 28-42), add two new properties:

```matlab
matFilePath = ''        % Path to source .mat file (for .ugm file discovery)
loadedMask = []         % Selection mask loaded at startup (for close comparison)
```

Add them after the `h5File` property (line 32).

**Part B: Wire matFilePath and loadedMask from tree's sourceFile**

In the constructor (around line 84-130), after `self.tree = treeObj` and `self.allEpochs = self.tree.allEpochs` are set, add:

```matlab
% Store .mat file path for .ugm file persistence
if ~isempty(self.tree.sourceFile)
    self.matFilePath = self.tree.sourceFile;
end

% Store loaded mask for close comparison (build from current isSelected state)
self.loadedMask = self.buildCurrentMask();
```

This ensures the GUI knows where the .mat file lives so it can discover/create .ugm files in the same directory. The loadedMask captures the initial selection state (whether from loaded .ugm or default all-selected) for comparison on close.

If the user creates a tree without using `loadEpicTreeData` (e.g., synthetic data), `matFilePath` will be empty and the save callback will prompt the user to locate their .mat file. This is the intended fallback. Users can also set `self.matFilePath` directly via property assignment if needed.
  </action>
  <verify>
Read epicTreeGUI.m and verify:
1. `matFilePath` property exists in properties block
2. `loadedMask` property exists in properties block
3. Constructor sets matFilePath from tree.sourceFile
4. Constructor calls buildCurrentMask() to populate loadedMask (method added in Task 2)
  </verify>
  <done>
- epicTreeGUI has `matFilePath` property
- epicTreeGUI has `loadedMask` property
- Constructor copies tree.sourceFile to matFilePath automatically
- Constructor captures initial mask in loadedMask for comparison on close
- Empty matFilePath fallback handled in save callback (Task 2)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Save Epoch Mask menu item, buildCurrentMask helper, and close handler</name>
  <files>epicTreeGUI.m</files>
  <action>
**Part A: Add buildCurrentMask() helper method**

Add a private method `mask = buildCurrentMask(self)` in the private methods section. This builds the selection mask from current isSelected flags (one-time operation).

```matlab
function mask = buildCurrentMask(self)
    % Build selection mask from current isSelected flags (one-time)
    if isempty(self.tree) || isempty(self.tree.allEpochs)
        mask = [];
        return;
    end

    allEps = self.tree.getAllEpochs(false);
    mask = false(length(allEps), 1);
    for i = 1:length(allEps)
        if isfield(allEps{i}, 'isSelected') && allEps{i}.isSelected
            mask(i) = true;
        end
    end
end
```

**Part B: Add menu item to buildMenuBar()**

In the `buildMenuBar()` method (line 281-298), add a "Save Epoch Mask..." menu item to the File menu, between "Export Selection..." and "Close":

Final File menu order:
1. Export Selection...
2. Save Epoch Mask... (new)
3. --- (separator)
4. Close

In code:
```matlab
fileMenu = uimenu(self.figure, 'Label', 'File');
uimenu(fileMenu, 'Label', 'Export Selection...', 'Callback', @(src,evt) self.onExportSelection());
uimenu(fileMenu, 'Label', 'Save Epoch Mask...', 'Callback', @(src,evt) self.onSaveEpochMask());
uimenu(fileMenu, 'Label', 'Close', 'Callback', @(src,evt) self.onClose(), 'Separator', 'on');
```

**Part C: Implement onSaveEpochMask() callback**

Add a private method `onSaveEpochMask(self)` in the private methods section.

Implementation:

```matlab
function onSaveEpochMask(self)
    % Save current selection state to .ugm file

    % Validate we have data and path
    if isempty(self.tree) || isempty(self.tree.allEpochs)
        errordlg('No data loaded.', 'Save Epoch Mask');
        return;
    end

    if isempty(self.matFilePath)
        % Ask user to specify the .mat file path
        [file, path] = uigetfile('*.mat', 'Select the source .mat file for this dataset');
        if file == 0
            return;  % User cancelled
        end
        self.matFilePath = fullfile(path, file);
        self.tree.sourceFile = self.matFilePath;
    end

    % Find existing .ugm files
    latestUGM = epicTreeTools.findLatestUGM(self.matFilePath);

    if isempty(latestUGM)
        % No existing files - create new
        filepath = epicTreeTools.generateUGMFilename(self.matFilePath);
        self.tree.saveUserMetadata(filepath);

        % Update loadedMask to current state (for close comparison)
        self.loadedMask = self.buildCurrentMask();

        msgbox(sprintf('Selection mask saved to:\n%s', filepath), 'Epoch Mask Saved');
    else
        % Existing files found - ask user
        % Use questdlg for broader MATLAB compatibility (works pre-R2020a too)
        choice = questdlg(...
            sprintf('Found existing selection file:\n%s\n\nReplace it or create a new one?', latestUGM), ...
            'Save Epoch Mask', ...
            'Replace Latest', 'Create New', 'Cancel', ...
            'Create New');

        switch choice
            case 'Replace Latest'
                self.tree.saveUserMetadata(latestUGM);

                % Update loadedMask to current state
                self.loadedMask = self.buildCurrentMask();

                msgbox(sprintf('Selection mask updated:\n%s', latestUGM), 'Epoch Mask Saved');
            case 'Create New'
                filepath = epicTreeTools.generateUGMFilename(self.matFilePath);
                self.tree.saveUserMetadata(filepath);

                % Update loadedMask to current state
                self.loadedMask = self.buildCurrentMask();

                msgbox(sprintf('Selection mask saved to:\n%s', filepath), 'Epoch Mask Saved');
            case 'Cancel'
                % Do nothing
        end
    end
end
```

Note: Using `questdlg()` instead of `uiconfirm()` for broader MATLAB version compatibility. `questdlg()` works with all MATLAB versions while `uiconfirm()` requires R2020a+ with App Designer figures.

**Part D: Update onClose() to implement close handler with compare/prompt**

Modify the existing `onClose()` method to add mask comparison logic:

```matlab
function onClose(self)
    % Close handler: compare current selection to loaded mask, prompt to save changes

    % Build current mask from isSelected flags (one-time)
    currentMask = self.buildCurrentMask();

    % Compare to loaded mask
    if ~isempty(self.loadedMask) && ~isempty(currentMask)
        % Check if masks differ
        if length(currentMask) == length(self.loadedMask)
            if ~isequal(currentMask, self.loadedMask)
                % Selection changed - prompt user
                choice = questdlg(...
                    'Selection state has changed since loading. Update mask with session changes?', ...
                    'Save Changes?', ...
                    'Update Mask', 'Discard Changes', 'Cancel', ...
                    'Update Mask');

                switch choice
                    case 'Update Mask'
                        % Save to latest .ugm or create new if none exists
                        if ~isempty(self.matFilePath)
                            latestUGM = epicTreeTools.findLatestUGM(self.matFilePath);
                            if isempty(latestUGM)
                                % Create new
                                filepath = epicTreeTools.generateUGMFilename(self.matFilePath);
                                self.tree.saveUserMetadata(filepath);
                            else
                                % Update latest
                                self.tree.saveUserMetadata(latestUGM);
                            end
                        end
                        % Continue closing
                    case 'Discard Changes'
                        % Continue closing without saving
                    case 'Cancel'
                        % Don't close
                        return;
                end
            end
        end
    end

    % Existing close logic (close figure)
    delete(self.figure);
end
```
  </action>
  <verify>
Read epicTreeGUI.m and verify:
1. `buildCurrentMask()` method exists in private methods
2. "Save Epoch Mask..." menu item exists in buildMenuBar
3. `onSaveEpochMask()` method exists in private methods
4. `onSaveEpochMask()` checks for empty data and empty matFilePath
5. `onSaveEpochMask()` uses questdlg for replace/create choice
6. `onSaveEpochMask()` calls `epicTreeTools.saveUserMetadata()` and `epicTreeTools.generateUGMFilename()`
7. `onSaveEpochMask()` updates loadedMask after saving
8. `onClose()` has been updated with mask comparison and prompt logic
9. `onClose()` builds current mask, compares to loadedMask, prompts if different

Then test using MCP MATLAB:
```matlab
% Quick smoke test - just verify the methods exist
methods('epicTreeGUI')  % Should list onSaveEpochMask and buildCurrentMask
```
  </verify>
  <done>
- `buildCurrentMask()` method exists and builds mask from isSelected flags (one-time)
- "Save Epoch Mask..." menu item appears in File menu
- Clicking it when no data loaded shows error dialog
- Clicking it when matFilePath is empty prompts for .mat file
- Clicking it with existing .ugm files shows Replace/Create/Cancel dialog
- Clicking it with no existing .ugm files creates new .ugm file directly
- Selection mask is saved via epicTreeTools.saveUserMetadata()
- loadedMask is updated after successful save
- Close handler builds current mask, compares to loadedMask
- Close handler prompts "Update mask with session changes?" if different
- Close handler offers Update/Discard/Cancel options
- Close handler saves to latest .ugm if user chooses Update
  </done>
</task>

</tasks>

<verification>
1. "Save Epoch Mask..." menu item exists in GUI File menu
2. `matFilePath` property is populated from tree.sourceFile in constructor
3. `loadedMask` property is populated from buildCurrentMask() in constructor
4. Save callback handles all three cases: no data, no existing .ugm, existing .ugm
5. Dialog prompts user with Replace/Create/Cancel when .ugm files exist
6. Close handler builds current mask from isSelected flags (one-time)
7. Close handler compares current mask to loadedMask
8. Close handler prompts "Update mask?" if masks differ
9. Close handler saves if user chooses Update
10. No regression: existing GUI functionality unchanged
</verification>

<success_criteria>
- GUI has functional "Save Epoch Mask" button in File menu per user's locked decision
- matFilePath flows correctly from tree.sourceFile to GUI
- loadedMask captures initial selection state for close comparison
- Save dialog matches user's specification: "Replace existing mask or create new one?"
- Close handler implements simplified architecture: build mask on close (one-time), compare, prompt
- Close handler matches user requirement: "Compare isSelected vs loaded mask, prompt 'Update mask?'"
- .ugm files are created in the same directory as the .mat file
</success_criteria>

<output>
After completion, create `.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-02-SUMMARY.md`
</output>
