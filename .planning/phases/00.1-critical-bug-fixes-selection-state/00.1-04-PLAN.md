---
phase: 00.1-critical-bug-fixes-selection-state
plan: 04
type: execute
wave: 4
depends_on: ["00.1-01", "00.1-02", "00.1-03"]
files_modified:
  - docs/SELECTION_STATE_ARCHITECTURE.md
  - CLAUDE.md
autonomous: true

must_haves:
  truths:
    - "Developer can read architecture doc and understand where selection state is stored (epoch.isSelected)"
    - "Developer can read architecture doc and understand how selection state propagates (parent to children, recursive)"
    - "Developer can read architecture doc and understand simplified architecture (build mask on save, copy on load, no sync)"
    - "User can read architecture doc and understand the three-file system (H5, .mat, .ugm)"
    - "User can read architecture doc and understand .ugm file discovery and loading behavior"
    - "Developer can read anti-patterns section and avoid BUG-001 mistake (modifying returned epoch copies)"
    - "Developer can read Python integration guide to use .ugm masks in RetinAnalysis/DataJoint"
  artifacts:
    - path: "docs/SELECTION_STATE_ARCHITECTURE.md"
      provides: "Complete documentation of selection state system, .ugm persistence, three-file architecture, simplified architecture, and Python integration"
      contains: "Storage Model, Hierarchy Propagation, Simplified Architecture, .ugm File Format, Discovery Logic, Close Handler Workflow, Anti-Patterns, Python Integration"
      min_lines: 200
    - path: "CLAUDE.md"
      provides: "Updated instructions for Claude Code covering .ugm persistence and selection state patterns"
      contains: "saveUserMetadata, loadUserMetadata, LoadUserMetadata constructor option, close handler pattern"
  key_links:
    - from: "docs/SELECTION_STATE_ARCHITECTURE.md Storage Model section"
      to: "epicTreeTools.m epoch.isSelected implementation"
      via: "Code references showing where isSelected flag lives"
    - from: "docs/SELECTION_STATE_ARCHITECTURE.md Simplified Architecture section"
      to: "epicTreeTools.saveUserMetadata implementation"
      via: "Documents one-time mask building on save (no real-time sync)"
    - from: "docs/SELECTION_STATE_ARCHITECTURE.md Python Integration section"
      to: "scipy.io.loadmat usage"
      via: "Example code showing how to read .ugm files in Python for database export"
---

<objective>
Document the selection state architecture, .ugm persistence system, and simplified architecture (build mask on save, copy on load, no sync) so developers and users understand how selection filtering works, avoiding future BUG-001-type issues. Include Python integration guide for RetinAnalysis/DataJoint workflows.

Purpose: Success criteria #5 requires "Architecture clearly documents where selection state lives and how it propagates." Without clear documentation, future developers might make the same mistake as BUG-001 (modifying returned epoch copies instead of using setSelected). Users also need to understand the three-file architecture to work effectively with .ugm files. Python users need to know how to read .ugm masks for database export workflows.

Output: SELECTION_STATE_ARCHITECTURE.md in docs/ directory with comprehensive architecture documentation including simplified architecture explanation and Python integration guide, plus updated CLAUDE.md with .ugm persistence patterns.
</objective>

<execution_context>
@/Users/maxwellsdm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/maxwellsdm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-CONTEXT.md
@.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-RESEARCH.md
@.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-01-SUMMARY.md
@.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-02-SUMMARY.md
@.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-03-SUMMARY.md
@src/tree/epicTreeTools.m
@BUGS_FOUND_PHASE0.md
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SELECTION_STATE_ARCHITECTURE.md with simplified architecture and Python integration</name>
  <files>docs/SELECTION_STATE_ARCHITECTURE.md</files>
  <action>
Create a comprehensive architecture document at `docs/SELECTION_STATE_ARCHITECTURE.md`.

**Structure:** Include all sections from the original plan, PLUS:
- New section: "Simplified Architecture" explaining the one-time mask building approach
- New section: "Close Handler Workflow" documenting the compare/prompt workflow
- New section: "Python Integration" with scipy.io examples for reading .ugm files

**Key additions for simplified architecture:**

```markdown
## Simplified Architecture: One-Time Mask Building

**Design principle:** Build mask only when needed (save/close), not during session.

**During Session (Source of Truth):**
- `epoch.isSelected` flag on each epoch struct
- Clicks update isSelected via `setSelected()` method
- `getAllEpochs(true)` filters by isSelected (loop is fine for typical dataset sizes)
- No centralized `selectionMask` property
- No real-time synchronization overhead

**On Save (One-Time Operation):**
```matlab
% Build mask from isSelected flags
allEps = tree.getAllEpochs(false);
mask = false(length(allEps), 1);
for i = 1:length(allEps)
    mask(i) = allEps{i}.isSelected;
end

% Save to .ugm file
ugm.selection_mask = mask;
save(filepath, 'ugm', '-v7.3');
```

**On Load (One-Time Operation):**
```matlab
% Load mask from .ugm file
loaded = load(filepath);
mask = loaded.ugm.selection_mask;

% Copy to isSelected flags
allEps = tree.getAllEpochs(false);
for i = 1:length(allEps)
    allEps{i}.isSelected = mask(i);
end

% Sync node cache
tree.refreshNodeSelectionState();
```

**Rationale:**
- Simple: isSelected is single source of truth during work
- Fast: No sync overhead on every click
- One-time comparison on close is not performance critical
- Avoids dual-storage synchronization bugs

## Close Handler Workflow

**On GUI window close:**

1. Build current mask from isSelected flags (one-time)
2. Compare to loadedMask (stored at startup)
3. If different: prompt "Update mask with session changes?"
4. If yes: save new mask to .ugm (update latest or create new)
5. Close window

**Implementation in epicTreeGUI.onClose():**
```matlab
currentMask = self.buildCurrentMask();
if ~isequal(currentMask, self.loadedMask)
    choice = questdlg('Update mask with session changes?', ...);
    if strcmp(choice, 'Update Mask')
        % Save to latest .ugm or create new
        tree.saveUserMetadata(latestUGM);
    end
end
delete(self.figure);
```

**User experience:**
- Explicit control: user chooses whether to save changes
- No auto-save surprises
- Can discard changes if needed
- Can cancel close if unsure

## Python Integration

**Reading .ugm files in Python (RetinAnalysis/DataJoint):**

The .ugm file is a MATLAB MAT file readable with `scipy.io.loadmat`:

```python
import scipy.io
import numpy as np

# Load .ugm file
ugm_path = 'experiment_2025-12-02_2026-02-08_14-30-45.ugm'
ugm = scipy.io.loadmat(ugm_path)

# Extract selection mask
# Note: MATLAB structs in scipy become nested arrays, need to unwrap
mask = ugm['ugm'][0, 0]['selection_mask'][0]  # Boolean array

# Verify epoch count matches
epoch_count = ugm['ugm'][0, 0]['epoch_count'][0, 0]
assert len(mask) == epoch_count, "Mask length mismatch"

# Filter epochs before export
# Assuming you have epochs array from .mat file
selected_epochs = epochs[mask]

print(f"Selected {np.sum(mask)} of {epoch_count} epochs ({100*np.sum(mask)/epoch_count:.1f}%)")
```

**Integration with database export:**

```python
# In your export_to_database.py workflow:

def export_with_selection_mask(mat_file, ugm_file=None):
    # Load experiment data
    data = scipy.io.loadmat(mat_file)
    epochs = extract_epochs(data)  # Your existing function

    # Apply selection mask if provided
    if ugm_file and os.path.exists(ugm_file):
        ugm = scipy.io.loadmat(ugm_file)
        mask = ugm['ugm'][0, 0]['selection_mask'][0]

        # Validate
        if len(mask) != len(epochs):
            print(f"Warning: Mask length ({len(mask)}) != epoch count ({len(epochs)})")
            print("Skipping mask application")
        else:
            epochs = epochs[mask]
            print(f"Applied selection mask: {len(epochs)} epochs selected")

    # Export to database
    export_to_datajoint(epochs)

# Usage:
export_with_selection_mask(
    'experiment.mat',
    ugm_file='experiment_2025-12-02_14-30-45.ugm'  # Optional
)
```

**Finding the latest .ugm file in Python:**

```python
import os
import glob

def find_latest_ugm(mat_file_path):
    """Find most recent .ugm file for a given .mat file"""
    directory = os.path.dirname(mat_file_path)
    basename = os.path.splitext(os.path.basename(mat_file_path))[0]

    # Search for matching .ugm files
    pattern = os.path.join(directory, f"{basename}_*.ugm")
    ugm_files = glob.glob(pattern)

    if not ugm_files:
        return None

    # Sort by filename (ISO 8601 timestamps sort correctly)
    ugm_files.sort(reverse=True)
    return ugm_files[0]

# Usage:
ugm_file = find_latest_ugm('experiment.mat')
if ugm_file:
    print(f"Found selection mask: {ugm_file}")
else:
    print("No selection mask found, using all epochs")
```

**Three-file workflow:**
1. Export H5 to MAT in Python (RetinAnalysis pipeline)
2. User loads MAT in MATLAB GUI, makes selections, saves .ugm
3. Python reads MAT + .ugm, filters epochs, exports to database
4. Database contains only user-selected epochs

**Note:** The .ugm file is optional. If not present, all epochs are considered selected.
```

**Full document structure:**
1. Overview
2. Storage Model (epoch.isSelected + node.custom.isSelected cache)
3. Simplified Architecture (NEW - one-time mask building)
4. Hierarchy Propagation
5. Filtering API (getAllEpochs, getSelectedData)
6. .ugm File Persistence
7. Three-File Architecture
8. .ugm File Format
9. Discovery Logic
10. Save/Load API
11. Constructor Options
12. GUI Integration
13. Close Handler Workflow (NEW - compare/prompt)
14. Common Anti-Patterns
15. Python Integration (NEW - scipy.io examples)
16. Testing
17. Implementation Files
18. Future Considerations

**Tone:** Technical but clear. Code examples throughout. Anti-patterns section prominently warns against BUG-001. Python section provides copy-paste examples for common workflows.
  </action>
  <verify>
Read docs/SELECTION_STATE_ARCHITECTURE.md and verify:
1. Storage Model section explains epoch.isSelected and node.custom.isSelected
2. Simplified Architecture section explains one-time mask building (NEW)
3. Close Handler Workflow section documents compare/prompt workflow (NEW)
4. Python Integration section shows scipy.io.loadmat examples (NEW)
5. Anti-Patterns section clearly documents BUG-001 mistake
6. .ugm File Format section shows all struct fields
7. Discovery Logic section explains findLatestUGM timestamp sorting
8. Constructor Options section shows all four modes (auto, latest, none, filepath)
9. Document is at least 200 lines (expanded from 150)
  </verify>
  <done>
- SELECTION_STATE_ARCHITECTURE.md exists in docs/ directory
- Document covers all aspects of selection state system
- Simplified Architecture section explains one-time mask building approach
- Close Handler Workflow section documents compare/prompt on close
- Python Integration section provides scipy.io examples for reading .ugm files
- Python section includes find_latest_ugm() helper and database export integration
- Anti-patterns section warns against modifying returned epoch copies (BUG-001 root cause)
- Three-file architecture (.h5, .mat, .ugm) clearly explained
- .ugm file format, discovery, and persistence fully documented
- Code examples throughout for clarity (MATLAB and Python)
  </done>
</task>

<task type="auto">
  <name>Task 2: Update CLAUDE.md with .ugm persistence patterns and close handler</name>
  <files>CLAUDE.md</files>
  <action>
Update CLAUDE.md to include .ugm persistence patterns and close handler workflow in the "Implementation Patterns" section.

**Add a new subsection after "Selection Management" (around line 228):**

```markdown
### .ugm Persistence Pattern
```matlab
% Save current selection state (builds mask from isSelected flags one-time)
filepath = epicTreeTools.generateUGMFilename(tree.sourceFile);
tree.saveUserMetadata(filepath);

% Load selection from .ugm file (copies mask to isSelected flags one-time)
success = tree.loadUserMetadata(filepath);
if ~success
    warning('Failed to load .ugm file');
end

% Find latest .ugm file
latestUGM = epicTreeTools.findLatestUGM(tree.sourceFile);
if ~isempty(latestUGM)
    tree.loadUserMetadata(latestUGM);
end

% Constructor options
tree = epicTreeTools(data);  % Auto-load latest .ugm if exists (default)
tree = epicTreeTools(data, 'LoadUserMetadata', 'latest');  % Error if none
tree = epicTreeTools(data, 'LoadUserMetadata', 'none');    % Start fresh
tree = epicTreeTools(data, 'LoadUserMetadata', 'path/to/file.ugm');
```

**Three-file architecture:**
- H5 file (optional): Raw experiment data
- MAT file (required): Exported epoch structure from Python
- UGM file (optional): User-generated metadata (selection mask)

**Simplified architecture:**
- `epoch.isSelected` = source of truth during session
- Mask built ONE-TIME when saving (no centralized mask property)
- Mask copied ONE-TIME when loading (no real-time sync overhead)
- Close handler compares current mask to loaded mask, prompts to save if changed

See `docs/SELECTION_STATE_ARCHITECTURE.md` for full documentation.
```

**Update the "Critical Functions to Know" section (around line 235) to include:**

Under "Data access:" add:
- `epicTreeTools.saveUserMetadata(filepath)` - Save selection state to .ugm file (builds mask from isSelected one-time)
- `epicTreeTools.loadUserMetadata(filepath)` - Load selection state from .ugm file (copies mask to isSelected one-time)
- `epicTreeTools.findLatestUGM(matFilePath)` - Find newest .ugm file (static)
- `epicTreeTools.generateUGMFilename(matFilePath)` - Generate timestamped .ugm filename (static)
- `epicTreeTools.refreshNodeSelectionState()` - Sync node.custom.isSelected with epoch states

**Update the "Important Notes" section (around line 245) to add after "Selection state is CRITICAL":**

```markdown
### .ugm files persist selection state
The .ugm (User-Generated Metadata) files store which epochs are selected. These are separate from the .mat file to keep user modifications isolated from raw experiment data. By default, `epicTreeTools(data)` auto-loads the latest .ugm file if one exists. Use `'LoadUserMetadata', 'none'` to start fresh.

**Simplified architecture:** No centralized `selectionMask` property. The `epoch.isSelected` flag on each epoch is the source of truth during session. Mask is built only when saving (one-time operation). On load, mask is copied to `isSelected` flags (one-time operation). No real-time sync overhead. Close handler compares current mask to loaded mask and prompts to save if changed.

**Python integration:** .ugm files are readable in Python via `scipy.io.loadmat()`. See `docs/SELECTION_STATE_ARCHITECTURE.md` for RetinAnalysis/DataJoint integration examples.
```

**Add a new "GUI Close Handler" subsection in Implementation Patterns:**

```markdown
### GUI Close Handler Pattern
```matlab
% In epicTreeGUI.onClose():

% Build current mask from isSelected flags (one-time)
currentMask = self.buildCurrentMask();

% Compare to mask loaded at startup
if ~isequal(currentMask, self.loadedMask)
    % Prompt user
    choice = questdlg('Update mask with session changes?', ...);

    if strcmp(choice, 'Update Mask')
        % Save to latest .ugm or create new
        latestUGM = epicTreeTools.findLatestUGM(self.matFilePath);
        if isempty(latestUGM)
            filepath = epicTreeTools.generateUGMFilename(self.matFilePath);
        else
            filepath = latestUGM;
        end
        self.tree.saveUserMetadata(filepath);
    end
end

% Close figure
delete(self.figure);
```

**User experience:** Explicit control over saving changes. No auto-save surprises. Can discard changes or cancel close.
```
  </action>
  <verify>
Read CLAUDE.md and verify:
1. ".ugm Persistence Pattern" subsection exists in Implementation Patterns
2. "Simplified architecture" explanation is included with emphasis on one-time operations
3. "GUI Close Handler Pattern" subsection exists in Implementation Patterns
4. "Critical Functions to Know" includes the five .ugm methods (save, load, find, generate, refresh)
5. "Important Notes" section mentions .ugm file purpose, auto-loading, and simplified architecture
6. "Important Notes" section mentions Python integration with reference to architecture doc
7. Code examples show all four LoadUserMetadata options
8. Code examples show close handler compare/prompt workflow
  </verify>
  <done>
- CLAUDE.md updated with .ugm persistence patterns
- Examples show save, load, find, generate, refresh, and constructor options
- Simplified architecture explained with emphasis on one-time mask building (no sync)
- GUI Close Handler pattern documented with compare/prompt workflow
- Three-file architecture explained briefly with reference to full architecture doc
- Critical functions list includes .ugm methods
- Important notes warn about auto-loading behavior and explain simplified architecture
- Python integration mentioned with reference to architecture doc
  </done>
</task>

</tasks>

<verification>
1. docs/SELECTION_STATE_ARCHITECTURE.md exists and is comprehensive (200+ lines)
2. Simplified Architecture section clearly explains one-time mask building approach
3. Close Handler Workflow section documents compare/prompt on GUI close
4. Python Integration section provides scipy.io examples with find_latest_ugm() helper
5. Anti-patterns section clearly documents BUG-001 mistake (modifying returned copies)
6. .ugm file format, discovery, and persistence fully documented
7. CLAUDE.md updated with .ugm patterns in Implementation Patterns section
8. CLAUDE.md includes GUI Close Handler pattern subsection
9. CLAUDE.md Critical Functions includes .ugm methods
10. CLAUDE.md Important Notes mentions simplified architecture and Python integration
11. No regression: existing CLAUDE.md content unchanged except additions
</verification>

<success_criteria>
- Developers can read SELECTION_STATE_ARCHITECTURE.md and understand the entire selection state system
- Developers understand simplified architecture (build mask on save, copy on load, no sync)
- Developers understand close handler workflow (compare/prompt/save)
- Users understand the three-file architecture (.h5, .mat, .ugm) and when to use each
- Python developers can integrate .ugm masks into RetinAnalysis/DataJoint workflows using provided examples
- Anti-patterns section prevents future BUG-001-type mistakes
- CLAUDE.md provides quick reference for common .ugm persistence workflows
- Phase 0.1 success criteria #5 met: "Architecture clearly documents where selection state lives and how it propagates"
</success_criteria>

<output>
After completion, create `.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-04-SUMMARY.md`
</output>
