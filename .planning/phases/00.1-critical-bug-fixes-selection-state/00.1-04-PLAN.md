---
phase: 00.1-critical-bug-fixes-selection-state
plan: 04
type: execute
wave: 4
depends_on: ["00.1-01", "00.1-02", "00.1-03"]
files_modified:
  - docs/SELECTION_STATE_ARCHITECTURE.md
  - CLAUDE.md
autonomous: true

must_haves:
  truths:
    - "Developer can read architecture doc and understand where selection state is stored (epoch.isSelected)"
    - "Developer can read architecture doc and understand how selection state propagates (parent to children, recursive)"
    - "User can read architecture doc and understand the three-file system (H5, .mat, .ugm)"
    - "User can read architecture doc and understand .ugm file discovery and loading behavior"
    - "Developer can read anti-patterns section and avoid BUG-001 mistake (modifying returned epoch copies)"
  artifacts:
    - path: "docs/SELECTION_STATE_ARCHITECTURE.md"
      provides: "Complete documentation of selection state system, .ugm persistence, and three-file architecture"
      contains: "Storage Model, Hierarchy Propagation, .ugm File Format, Discovery Logic, Anti-Patterns"
      min_lines: 150
    - path: "CLAUDE.md"
      provides: "Updated instructions for Claude Code covering .ugm persistence and selection state patterns"
      contains: "saveUserMetadata, loadUserMetadata, LoadUserMetadata constructor option"
  key_links:
    - from: "docs/SELECTION_STATE_ARCHITECTURE.md Storage Model section"
      to: "epicTreeTools.m epoch.isSelected implementation"
      via: "Code references showing where isSelected flag lives"
    - from: "docs/SELECTION_STATE_ARCHITECTURE.md .ugm File Format section"
      to: "epicTreeTools.saveUserMetadata implementation"
      via: "Struct field documentation matching actual code"
---

<objective>
Document the selection state architecture and .ugm persistence system so developers and users understand how selection filtering works, avoiding future BUG-001-type issues.

Purpose: Success criteria #5 requires "Architecture clearly documents where selection state lives and how it propagates." Without clear documentation, future developers might make the same mistake as BUG-001 (modifying returned epoch copies instead of using setSelected). Users also need to understand the three-file architecture to work effectively with .ugm files.

Output: SELECTION_STATE_ARCHITECTURE.md in docs/ directory with comprehensive architecture documentation, plus updated CLAUDE.md with .ugm persistence patterns.
</objective>

<execution_context>
@/Users/maxwellsdm/.claude/get-shit-done/workflows/execute-plan.md
@/Users/maxwellsdm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-CONTEXT.md
@.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-RESEARCH.md
@.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-01-SUMMARY.md
@.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-02-SUMMARY.md
@.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-03-SUMMARY.md
@src/tree/epicTreeTools.m
@BUGS_FOUND_PHASE0.md
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SELECTION_STATE_ARCHITECTURE.md</name>
  <files>docs/SELECTION_STATE_ARCHITECTURE.md</files>
  <action>
Create a comprehensive architecture document at `docs/SELECTION_STATE_ARCHITECTURE.md`.

**Structure:**

```markdown
# Selection State Architecture

Last updated: 2026-02-15
Related: BUG-001 (Phase 0 testing discovered selection state not filtering correctly)

## Overview

The epicTreeGUI selection state system allows users to filter epochs for analysis by selecting/deselecting nodes in the tree. This document explains:
- Where selection state is stored
- How it propagates through the tree hierarchy
- How it persists across sessions (.ugm files)
- Common anti-patterns to avoid

## Storage Model

### Per-Epoch Flag (Primary)

Selection state is stored as a boolean flag on **each individual epoch struct**:

```matlab
epoch.isSelected = true;  % or false
```

**Location:** Leaf nodes' `epochList` property contains the actual epoch structs with the flag.

**Why per-epoch?**
- Simple and direct: "is this epoch selected?"
- No synchronization issues between separate data structures
- Works naturally with MATLAB struct arrays

### Node-Level Cache (Secondary)

Each tree node also caches its selection state in `node.custom.isSelected`:

```matlab
node.custom.isSelected = anyEpochsSelected;
```

**Purpose:** Fast checkbox rendering without traversing all epochs every frame.

**Synchronization:** Call `refreshNodeSelectionState()` after loading .ugm files to sync cache with actual epoch states.

## Hierarchy Propagation

Selection state propagates **parent to children** using recursive logic.

### Deselecting a Node

When `setSelected(false, true)` is called on a node:
1. All epochs under that node are marked `isSelected = false`
2. All child nodes recursively deselected
3. Node cache `node.custom.isSelected = false`

### Selecting a Node

When `setSelected(true, true)` is called on a node:
1. All epochs under that node are marked `isSelected = true`
2. All child nodes recursively selected
3. Node cache `node.custom.isSelected = true`

### Root Node Special Case

- Selecting root → select all epochs in tree
- Deselecting root → deselect all epochs in tree
- Simple "select all" / "deselect all" convenience

## Filtering API

### getAllEpochs(onlySelected)

**Purpose:** Flatten tree to epoch list with optional selection filtering.

```matlab
% Get all epochs regardless of selection
allEpochs = tree.getAllEpochs(false);

% Get only selected epochs (THIS is what analysis functions use)
selectedEpochs = tree.getAllEpochs(true);
```

**Implementation (conceptual):**
```matlab
function epochs = getAllEpochs(obj, onlySelected)
    epochs = obj.allEpochs;  % or collect from children
    if onlySelected
        selected = cellfun(@(e) e.isSelected, epochs);
        epochs = epochs(selected);
    end
end
```

### getSelectedData(nodeOrEpochs, streamName)

**Purpose:** Extract response data for analysis.

**Critical behavior:** Calls `getAllEpochs(true)` internally, so it automatically respects selection state.

```matlab
[data, epochs, fs] = getSelectedData(tree, 'Amp1');
% Only includes epochs where isSelected == true
```

### selectedCount() and epochCount()

```matlab
total = node.epochCount();      % All epochs under this node
selected = node.selectedCount(); % Only selected epochs
```

## .ugm File Persistence

### Three-File Architecture

The system uses **three data layers**:

1. **Raw H5 files** (`experiment.h5`) - Optional, read-only, never modified
2. **Exported metadata** (`experiment.mat`) - Required, contains epoch structure from Python export
3. **User-generated metadata** (`experiment_YYYY-MM-DD_HH-MM-SS.ugm`) - Optional, contains selection mask

**Key principle:** Keep user modifications (selections) separate from raw experiment data.

### .ugm File Format

.ugm files are MATLAB MAT files (v7.3) containing a single `ugm` struct:

```matlab
ugm.version = '1.0';                    % Format version for future migrations
ugm.created = datetime('now');          % Timestamp
ugm.epoch_count = 1916;                 % Total epochs (validation check)
ugm.mat_file_basename = 'experiment';   % Source .mat file basename
ugm.selection_mask = logical([1 0 1 1 0 ...]); % Per-epoch selection state
```

**selection_mask:** Logical array matching `tree.allEpochs` index-for-index.

### Naming Convention

**Format:** `{mat_basename}_YYYY-MM-DD_HH-MM-SS.ugm`

**Example:** `2025-12-02_F_2026-02-08_14-30-45.ugm`

**Location:** Same directory as the .mat file

**Timestamp:** Auto-generated when saved (ISO 8601 sortable)

### Discovery Logic

**Finding the latest .ugm:**

```matlab
filepath = epicTreeTools.findLatestUGM(matFilePath);
% Searches for: {basename}_*.ugm
% Sorts filenames descending (timestamp sorts lexicographically)
% Returns newest match or empty string if none found
```

### Save/Load API

**Save:**
```matlab
% Generate timestamped filename
filepath = epicTreeTools.generateUGMFilename(tree.sourceFile);

% Save current selection state
tree.saveUserMetadata(filepath);
```

**Load:**
```matlab
% Load specific file
success = tree.loadUserMetadata(filepath);

% Validates:
% - File exists
% - Contains ugm struct with required fields
% - ugm.epoch_count matches tree.epochCount()
% Applies selection_mask to tree.allEpochs
% Calls refreshNodeSelectionState() to sync node cache
```

### Constructor Options

**Default (auto-load latest):**
```matlab
tree = epicTreeTools(data);
% → Looks for .ugm files in same directory as data.source_file
% → If found: loads newest automatically
% → If not found: all epochs selected by default
```

**Explicit control:**
```matlab
% Load latest, error if none exists
tree = epicTreeTools(data, 'LoadUserMetadata', 'latest');

% Skip loading entirely
tree = epicTreeTools(data, 'LoadUserMetadata', 'none');

% Load specific file
tree = epicTreeTools(data, 'LoadUserMetadata', '/path/to/file.ugm');
```

## GUI Integration

### Save Epoch Mask Button

**Location:** File menu → "Save Epoch Mask..."

**Behavior:**
1. Checks for existing .ugm files in same directory as .mat file
2. If none exist: Creates new .ugm file directly
3. If exist: Prompts "Replace latest or create new?"
4. Calls `tree.saveUserMetadata(filepath)`

**Manual save only:** NOT auto-save. User has explicit control.

### matFilePath Property

The GUI stores `matFilePath` copied from `tree.sourceFile`. This enables .ugm file discovery without requiring the user to specify the directory every time.

**Flow:**
```
loadEpicTreeData() sets data.source_file
  ↓
epicTreeTools constructor reads data.source_file → tree.sourceFile
  ↓
epicTreeGUI constructor reads tree.sourceFile → gui.matFilePath
  ↓
Save Epoch Mask button uses matFilePath for .ugm discovery/creation
```

## Common Anti-Patterns

### ANTI-PATTERN 1: Modifying Returned Epoch Copies

**WRONG:**
```matlab
epochs = tree.getAllEpochs(false);
for i = 1:length(epochs)
    epochs{i}.isSelected = false;  % Modifying a COPY - has no effect!
end
```

**Why it fails:** `getAllEpochs()` returns a **copy** of the epoch structs. Modifying the copy doesn't affect the originals stored in leaf nodes.

**ROOT CAUSE of BUG-001:** Test code was modifying returned copies instead of using the API.

**CORRECT:**
```matlab
node.setSelected(false, true);  % Use the API, modifies originals
```

### ANTI-PATTERN 2: Dual Storage Without Sync

**WRONG:**
```matlab
% Storing selection mask separately from epoch.isSelected
tree.selectionMask = logical(...);  % Separate array
% Now you have TWO sources of truth that can get out of sync!
```

**Why it fails:** Synchronization bugs. Which is correct when they disagree?

**CORRECT:** Use per-epoch flags as the single source of truth. Build masks on-demand when saving .ugm.

### ANTI-PATTERN 3: Skipping refreshNodeSelectionState After Load

**WRONG:**
```matlab
tree.loadUserMetadata(filepath);
% Node checkboxes show wrong state because node.custom.isSelected not synced!
```

**CORRECT:**
```matlab
tree.loadUserMetadata(filepath);
% Internally calls refreshNodeSelectionState() to sync node cache
```

The `loadUserMetadata()` method handles this automatically. But if you manually modify `epoch.isSelected` flags, you must call `refreshNodeSelectionState()` yourself.

## Testing

Selection state tests are in:
- `tests/test_selection_state.m` - Core filtering logic (10 tests)
- `tests/test_ugm_persistence.m` - .ugm save/load round-trips (13 tests)

**Key test coverage:**
- setSelected + getAllEpochs(true) filtering
- Recursive propagation (parent to children)
- Root select/deselect all
- .ugm save/load round-trip preserves selection
- Epoch count validation
- findLatestUGM timestamp sorting
- Constructor LoadUserMetadata options

## Implementation Files

| File | Purpose |
|------|---------|
| `src/tree/epicTreeTools.m` | Core selection methods (setSelected, getAllEpochs, selectedCount, saveUserMetadata, loadUserMetadata, findLatestUGM, generateUGMFilename, refreshNodeSelectionState) |
| `src/getSelectedData.m` | Analysis data extraction (calls getAllEpochs(true)) |
| `src/loadEpicTreeData.m` | Stores source_file in returned data struct |
| `epicTreeGUI.m` | Save Epoch Mask button, matFilePath property |
| `tests/test_selection_state.m` | Selection filtering tests |
| `tests/test_ugm_persistence.m` | .ugm persistence tests |

## Future Considerations

### Partial Selection UI

Currently no "indeterminate" checkbox state (node partially selected). All nodes show binary selected/deselected based on `anyEpochsSelected`.

**If adding partial selection indicators:**
- Modify `refreshNodeSelectionState()` to detect partial state
- Add `node.custom.selectionState` = 'all' | 'none' | 'partial'
- Update graphicalTree checkbox rendering

### .ugm Format Versioning

Current version: `'1.0'`

**If format changes:**
- Increment version string ('2.0')
- Add migration logic in `loadUserMetadata()`:
  ```matlab
  if strcmp(ugm.version, '1.0')
      ugm = migrateFrom1to2(ugm);
  end
  ```
- Keep backward compatibility for at least one version

### Performance with Large Datasets

Current implementation: O(n) iteration over all epochs when filtering.

**If dataset grows to 100k+ epochs:**
- Consider caching filtered lists per node
- Invalidate cache on setSelected()
- Trade memory for speed

### Multiple Selection Sets

Current: One selection mask per session (.ugm file).

**If users want multiple named selections:**
- Add `ugm.name` field
- GUI: dropdown to switch between saved selections
- NOT planned for v1.0 - users can manage multiple .ugm files manually

---

*Document created: 2026-02-15 (Phase 0.1)*
*Last updated: 2026-02-15*
```

**Key sections:**
1. Storage Model - where selection state lives (epoch.isSelected + node.custom.isSelected cache)
2. Hierarchy Propagation - how parent deselect cascades to children
3. Filtering API - getAllEpochs(true), getSelectedData()
4. .ugm File Persistence - three-file architecture, format, discovery
5. Common Anti-Patterns - avoiding BUG-001 mistakes
6. Testing - reference to test suites
7. Implementation Files - quick lookup table
8. Future Considerations - versioning, performance, extensions

**Tone:** Technical but clear. Code examples throughout. Anti-patterns section prominently warns against BUG-001.
  </action>
  <verify>
Read docs/SELECTION_STATE_ARCHITECTURE.md and verify:
1. Storage Model section explains epoch.isSelected and node.custom.isSelected
2. Anti-Patterns section clearly documents BUG-001 mistake
3. .ugm File Format section shows all struct fields
4. Discovery Logic section explains findLatestUGM timestamp sorting
5. Constructor Options section shows all four modes (auto, latest, none, filepath)
6. Document is at least 150 lines
  </verify>
  <done>
- SELECTION_STATE_ARCHITECTURE.md exists in docs/ directory
- Document covers all aspects of selection state system
- Anti-patterns section warns against modifying returned epoch copies (BUG-001 root cause)
- Three-file architecture (.h5, .mat, .ugm) clearly explained
- .ugm file format, discovery, and persistence fully documented
- Code examples throughout for clarity
  </done>
</task>

<task type="auto">
  <name>Task 2: Update CLAUDE.md with .ugm persistence patterns</name>
  <files>CLAUDE.md</files>
  <action>
Update CLAUDE.md to include .ugm persistence patterns in the "Implementation Patterns" section.

**Add a new subsection after "Selection Management" (around line 228):**

```markdown
### .ugm Persistence Pattern
```matlab
% Save current selection state
filepath = epicTreeTools.generateUGMFilename(tree.sourceFile);
tree.saveUserMetadata(filepath);

% Load selection from .ugm file
success = tree.loadUserMetadata(filepath);
if ~success
    warning('Failed to load .ugm file');
end

% Find latest .ugm file
latestUGM = epicTreeTools.findLatestUGM(tree.sourceFile);
if ~isempty(latestUGM)
    tree.loadUserMetadata(latestUGM);
end

% Constructor options
tree = epicTreeTools(data);  % Auto-load latest .ugm if exists
tree = epicTreeTools(data, 'LoadUserMetadata', 'latest');  % Error if none
tree = epicTreeTools(data, 'LoadUserMetadata', 'none');    % Start fresh
tree = epicTreeTools(data, 'LoadUserMetadata', 'path/to/file.ugm');
```

**Three-file architecture:**
- H5 file (optional): Raw experiment data
- MAT file (required): Exported epoch structure from Python
- UGM file (optional): User-generated metadata (selection mask)

See `docs/SELECTION_STATE_ARCHITECTURE.md` for full documentation.
```

**Update the "Critical Functions to Know" section (around line 235) to include:**

Under "Data access:" add:
- `epicTreeTools.saveUserMetadata(filepath)` - Save selection state to .ugm file
- `epicTreeTools.loadUserMetadata(filepath)` - Load selection state from .ugm file
- `epicTreeTools.findLatestUGM(matFilePath)` - Find newest .ugm file (static)
- `epicTreeTools.generateUGMFilename(matFilePath)` - Generate timestamped .ugm filename (static)

**Update the "Important Notes" section (around line 245) to add after "Selection state is CRITICAL":**

```markdown
### .ugm files persist selection state
The .ugm (User-Generated Metadata) files store which epochs are selected. These are separate from the .mat file to keep user modifications isolated from raw experiment data. By default, `epicTreeTools(data)` auto-loads the latest .ugm file if one exists. Use `'LoadUserMetadata', 'none'` to start fresh.
```
  </action>
  <verify>
Read CLAUDE.md and verify:
1. ".ugm Persistence Pattern" subsection exists in Implementation Patterns
2. "Critical Functions to Know" includes the four .ugm methods
3. "Important Notes" section mentions .ugm file purpose and auto-loading
4. Code examples show all four LoadUserMetadata options
  </verify>
  <done>
- CLAUDE.md updated with .ugm persistence patterns
- Examples show save, load, find, generate, and constructor options
- Three-file architecture explained briefly with reference to full architecture doc
- Critical functions list includes .ugm methods
- Important notes warn about auto-loading behavior
  </done>
</task>

</tasks>

<verification>
1. docs/SELECTION_STATE_ARCHITECTURE.md exists and is comprehensive (150+ lines)
2. Anti-patterns section clearly documents BUG-001 mistake (modifying returned copies)
3. .ugm file format, discovery, and persistence fully documented
4. CLAUDE.md updated with .ugm patterns in Implementation Patterns section
5. CLAUDE.md Critical Functions includes .ugm methods
6. No regression: existing CLAUDE.md content unchanged except additions
</verification>

<success_criteria>
- Developers can read SELECTION_STATE_ARCHITECTURE.md and understand the entire selection state system
- Users understand the three-file architecture (.h5, .mat, .ugm) and when to use each
- Anti-patterns section prevents future BUG-001-type mistakes
- CLAUDE.md provides quick reference for common .ugm persistence workflows
- Phase 0.1 success criteria #5 met: "Architecture clearly documents where selection state lives and how it propagates"
</success_criteria>

<output>
After completion, create `.planning/phases/00.1-critical-bug-fixes-selection-state/00.1-04-SUMMARY.md`
</output>
