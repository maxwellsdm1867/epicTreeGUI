# EpicTreeGUI: Pure MATLAB Epoch Tree Browser

---
## ğŸ“Š CURRENT STATUS (January 2026)

**MVP: âœ… COMPLETE** | **Full Feature Parity: ~75%**

| Component | Status | Files |
|-----------|--------|-------|
| Core Tree Class | âœ… Complete | `epicTreeTools.m` (1700+ lines, 20+ splitters, navigation, controlled access) |
| GUI Framework | âœ… Complete | `epicTreeGUI.m`, `graphicalTree.m`, `graphicalTreeNode.m`, `graphicalTreeNodeWidget.m`, `graphicalCheckBox.m` |
| Data Viewer | âœ… Complete | `singleEpoch.m` |
| Data Utilities | âœ… Complete | `getSelectedData.m`, `getResponseMatrix.m`, `getTreeEpochs.m`, `loadH5ResponseData.m` |
| Config System | âœ… Complete | `epicTreeConfig.m`, `getH5FilePath.m` (retinanalysis-style) |
| H5 Lazy Loading | âœ… Complete | Data loaded on-demand from H5 files |
| Analysis Functions | âš ï¸ 4/8 | `getMeanResponseTrace.m`, `getResponseAmplitudeStats.m`, `getCycleAverageResponse.m`, `getLinearFilterAndPrediction.m` |
| Documentation | ğŸ”² Pending | User guide, examples |

**What Works Now:**
```matlab
% Configure H5 directory (like retinanalysis H5_DIR)
epicTreeConfig('h5_dir', '/Users/data/h5');

% Load tree and get H5 file path
gui = epicTreeGUI('data.mat');
h5_file = getH5FilePath(exp_name);

% Get selected data (lazy-loads from H5)
[data, epochs, fs] = getSelectedData(node, 'Amp1', h5_file);
result = getMeanResponseTrace(data, fs);
```

**Tree Navigation Pattern:**
```matlab
% Build tree with splitters
tree = epicTreeTools(data);
tree.buildTree({'cellInfo.type', 'blockInfo.protocol_name', 'parameters.contrast'});

% Navigate DOWN
for i = 1:tree.childrenLength()
    cellTypeNode = tree.childAt(i);
    for j = 1:cellTypeNode.childrenLength()
        protocolNode = cellTypeNode.childAt(j);
        leaves = protocolNode.leafNodes();
    end
end

% Navigate UP
leaf = leaves{1};
d = leaf.depth();                    % How deep is this node?
parentNode = leaf.parentAt(d-1);     % Get ancestor at level
root = leaf.getRoot();               % Get root
pathStr = leaf.pathString();         % "OnP > FlashProtocol > 0.5"

% Controlled access (no direct property assignment)
node.putCustom('results', struct('mean', 42.5, 'n', 10));
results = node.getCustom('results');
hasResults = node.hasCustom('results');
node.removeCustom('results');
```

**Remaining Work:**
- Port 4 analysis functions from old_epochtree/ (RFAnalysis, LSTA, CenterSurround, MeanSelectedNodes)
- User documentation and examples

**Usage Pattern (Programmatic Split Configuration):**
```matlab
% User defines split keys programmatically (not via dropdown)
tree = epicTreeTools(data);
tree.buildTreeWithSplitters({
    'cellInfo.type', ...
    @epicTreeTools.splitOnExperimentDate, ...
    'cellInfo.label', ...
    'parameters.imageName', ...
    @epicTreeTools.splitOnKeywords, ...
    'parameters.equivalentIntensity'
});
```

**H5 Lazy Loading (retinanalysis pattern):**
- `.mat` files contain metadata + `h5_path` for each response
- Actual data loaded from H5 files on demand
- Config system: `epicTreeConfig('h5_dir', path)` sets H5 directory
- Helper: `getH5FilePath(exp_name)` constructs full H5 path

---

## Executive Summary

Build a **pure MATLAB** GUI for browsing and analyzing epoch data, replicating ALL functionality from the legacy Rieke Lab epoch tree system (Java/MATLAB), but operating on the standardized data format defined in [DATA_FORMAT_SPECIFICATION.md](DATA_FORMAT_SPECIFICATION.md).

**Key Design Decisions:**
1. **Pure MATLAB** - No Java dependencies. All functionality implemented in native MATLAB.
2. **Standard Data Format** - Uses `.mat` files conforming to [DATA_FORMAT_SPECIFICATION.md](DATA_FORMAT_SPECIFICATION.md)
3. **Full Feature Parity** - Replicates ALL functionality from old epochtree system

**Reference Documents:**
- [EPOCH_TREE_SYSTEM_COMPREHENSIVE_GUIDE.md](EPOCH_TREE_SYSTEM_COMPREHENSIVE_GUIDE.md) - Complete technical analysis of legacy system
- [DATA_FORMAT_SPECIFICATION.md](DATA_FORMAT_SPECIFICATION.md) - Input data format specification
- [JAUIMODEL_FUNCTION_INVENTORY.md](JAUIMODEL_FUNCTION_INVENTORY.md) - Legacy Java API reference

---

## 1. ARCHITECTURE OVERVIEW

### 1.1 System Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DATA PACKAGING LAYER (External)                           â”‚
â”‚  Python/DataJoint â†’ Exports to Standard .mat Format                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚ Standard .mat file
                               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       PURE MATLAB EPIC TREE GUI                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚  EpochData.m    â”‚   â”‚  EpochTree.m    â”‚   â”‚  Epoch.m        â”‚           â”‚
â”‚  â”‚  (Data Loader)  â”‚â”€â”€â–¶â”‚  (Tree Node)    â”‚â”€â”€â–¶â”‚  (Single Epoch) â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚           â”‚                    â”‚                                             â”‚
â”‚           â–¼                    â–¼                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚                    epicTreeGUI.m                             â”‚           â”‚
â”‚  â”‚  â”œâ”€â”€ Tree Browser Panel (graphicalTree)                     â”‚           â”‚
â”‚  â”‚  â”œâ”€â”€ Viewer Panel (singleEpoch)                             â”‚           â”‚
â”‚  â”‚  â””â”€â”€ Split Key Selector                                      â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚           â”‚                                                                  â”‚
â”‚           â–¼                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚              Analysis Functions & Utilities                   â”‚           â”‚
â”‚  â”‚  getMeanResponseTrace, getSelectedData, RFAnalysis, etc.     â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 Key Insight: Dynamic Tree Organization

The epoch tree is NOT a static visualizationâ€”it's a **dynamic data organization system**. The same epochs can be viewed through different organizational lenses by changing the split keys.

**Example:** 100 epochs, same data, different organization:
```
Split by Cell Type:           Split by Contrast:
Root                          Root
â”œâ”€â”€ OnP (40 epochs)           â”œâ”€â”€ contrast=0.3 (25 epochs)
â”‚   â”œâ”€â”€ Epoch 1               â”‚   â”œâ”€â”€ Epoch 1
â”‚   â””â”€â”€ ...                   â”‚   â””â”€â”€ ...
â”œâ”€â”€ OffP (35 epochs)          â”œâ”€â”€ contrast=0.5 (35 epochs)
â”‚   â””â”€â”€ ...                   â”‚   â””â”€â”€ ...
â””â”€â”€ OnM (25 epochs)           â””â”€â”€ contrast=0.8 (40 epochs)
    â””â”€â”€ ...                       â””â”€â”€ ...
```

**User switches dropdown â†’ entire tree rebuilds with different hierarchy.**

---

## 2. DATA FORMAT MAPPING

### 2.1 Input: Standard Data Format

The GUI reads `.mat` files conforming to [DATA_FORMAT_SPECIFICATION.md](DATA_FORMAT_SPECIFICATION.md):

```matlab
data = struct(...
    'format_version', '1.0', ...
    'metadata', metadata_struct, ...
    'experiments', experiments_array ...  % Array of experiment structs
);

% Each experiment contains:
experiment.cells â†’ cell.epoch_groups â†’ epoch_group.epoch_blocks â†’ epoch_block.epochs â†’ epoch

% Each epoch contains:
epoch.id
epoch.parameters          % Protocol settings (contrast, size, etc.)
epoch.responses           % Array of response structs
epoch.stimuli             % Array of stimulus structs
epoch.start_time
epoch.frame_times_ms
```

### 2.2 Mapping: Legacy API â†’ New Data Format

| Legacy Java API | New MATLAB Equivalent | Data Source |
|-----------------|----------------------|-------------|
| `epoch.protocolSettings.get('contrast')` | `epoch.parameters.contrast` | epoch.parameters struct |
| `epoch.protocolSettings.get('preTime')` | `epoch.parameters.preTime` | epoch.parameters struct |
| `epoch.responses.get('Amp1').data()` | `epoch.responses(1).data` | epoch.responses array |
| `epoch.cell.label` | `cell.label` | Parent cell struct |
| `epoch.cell.experiment.startDate` | `experiment.start_time` | Parent experiment struct |
| `epochList.responseStreamNames()` | `getStreamNames(epochs, 'responses')` | Helper function |
| `riekesuite.getResponseMatrix(list, stream)` | `getResponseMatrix(epochList, streamName)` | Helper function |

### 2.3 Critical Function: getResponseMatrix

**Purpose:** Extract response data matrix from epoch list (THE most important data access function)

```matlab
function dataMatrix = getResponseMatrix(epochList, streamName)
    % Returns: [numEpochs Ã— numSamples] matrix of response data
    %
    % Legacy: riekesuite.getResponseMatrix(epochList, 'Amp1')
    % New:    getResponseMatrix(epochList, 'Amp1')

    numEpochs = length(epochList);

    % Get sample count from first epoch
    firstResponse = findResponse(epochList{1}, streamName);
    numSamples = length(firstResponse.data);

    % Pre-allocate
    dataMatrix = zeros(numEpochs, numSamples);

    % Extract data from each epoch
    for i = 1:numEpochs
        response = findResponse(epochList{i}, streamName);
        dataMatrix(i, :) = response.data;
    end
end

function response = findResponse(epoch, streamName)
    % Find response by device_name
    for i = 1:length(epoch.responses)
        if strcmp(epoch.responses(i).device_name, streamName)
            response = epoch.responses(i);
            return;
        end
    end
    error('Response stream not found: %s', streamName);
end
```

### 2.4 Critical Function: getSelectedData

**Purpose:** Get response matrix filtered by selection state (most-used analysis function)

```matlab
function epochData = getSelectedData(epochList, streamName)
    % Returns: Response matrix for only selected epochs
    %
    % This is THE critical function for all analysis workflows
    % Source: old_epochtree/tree-utils/getSelectedData.m

    % Get full response matrix
    tempData = getResponseMatrix(epochList, streamName);

    % Filter by isSelected flag
    isSelected = false(length(epochList), 1);
    for i = 1:length(epochList)
        isSelected(i) = epochList{i}.isSelected;
    end

    % Return only selected epochs
    selectedIndices = find(isSelected);
    epochData = tempData(selectedIndices, :);
end
```

---

## 3. TREE BUILDING ALGORITHM

### 3.1 Core Algorithm: buildTree

**This is the heart of the system.** Implements the same algorithm as `GenericEpochTreeFactory.create()`.

```matlab
function treeNode = buildTree(epochList, splitKeyPaths)
    % Build hierarchical tree from flat epoch list
    %
    % Input:
    %   epochList: Cell array of epoch structs
    %   splitKeyPaths: Cell array of split keys (strings or function handles)
    %
    % Output:
    %   treeNode: Root EpochTree node
    %
    % Algorithm:
    %   1. If no split keys left, create leaf node with epochList
    %   2. Otherwise, group epochs by value at first key
    %   3. Create child node for each unique value
    %   4. Recursively build subtrees with remaining keys

    % Create root node
    treeNode = EpochTree();
    treeNode.splitKeyPaths = splitKeyPaths;

    % Call recursive helper
    buildTreeHelper(treeNode, epochList, splitKeyPaths);
end

function buildTreeHelper(node, epochs, keyPaths)
    if isempty(keyPaths)
        % BASE CASE: Leaf node - store epochs here
        node.isLeaf = true;
        node.epochList = epochs;
        return;
    end

    % Get current split key
    currentKey = keyPaths{1};
    remainingKeys = keyPaths(2:end);

    % Group epochs by value at this key
    groups = groupEpochsByKey(epochs, currentKey);

    % Sort groups by split value
    groups = sortGroupsByValue(groups);

    % Create child node for each unique value
    node.isLeaf = false;
    node.children = {};

    for i = 1:length(groups)
        child = EpochTree();
        child.splitKey = currentKey;
        child.splitValue = groups{i}.value;
        child.parent = node;

        % Recursively build subtree
        buildTreeHelper(child, groups{i}.epochs, remainingKeys);

        node.children{end+1} = child;
    end
end
```

### 3.2 Split Key Types

The system supports TWO types of split keys:

#### Type 1: String Key Paths (Direct Property Access)

```matlab
% Dot notation for nested properties
'parameters.contrast'           % epoch.parameters.contrast
'parameters.preTime'            % epoch.parameters.preTime
'cell.label'                    % epoch's parent cell label
'cell.type'                     % epoch's parent cell type

% Legacy syntax support (protocolSettings)
'protocolSettings(contrast)'    % Maps to: epoch.parameters.contrast
```

**Key Path Resolution:**
```matlab
function value = resolveKeyPath(epoch, keyPath)
    % Handle legacy protocolSettings syntax
    if startsWith(keyPath, 'protocolSettings(')
        paramName = extractBetween(keyPath, '(', ')');
        keyPath = ['parameters.' paramName{1}];
    end

    % Split path and traverse
    parts = strsplit(keyPath, '.');
    value = epoch;
    for i = 1:length(parts)
        if isstruct(value) && isfield(value, parts{i})
            value = value.(parts{i});
        else
            value = [];  % Path not found
            return;
        end
    end
end
```

#### Type 2: Custom Split Functions

For complex splitting logic that can't be expressed as a key path:

```matlab
% Define custom split function
function value = splitOnExperimentDate(epoch)
    % Access parent experiment's start time
    value = datestr(epoch.experiment.start_time, 'yyyy-mm-dd');
end

function value = splitOnKeywords(epoch)
    % Concatenate all keywords
    if isfield(epoch, 'keywords') && ~isempty(epoch.keywords)
        value = strjoin(epoch.keywords, ', ');
    else
        value = 'no keywords';
    end
end

function value = splitOnCellType(epoch)
    % Get cell type from parent cell
    value = epoch.cell.type;
end
```

**Using Custom Functions:**
```matlab
% Build tree with mix of key paths and functions
tree = buildTree(epochList, {
    @splitOnExperimentDate,       % Level 1: Date
    'cell.label',                 % Level 2: Cell ID
    'parameters.contrast',        % Level 3: Contrast
    @splitOnKeywords              % Level 4: Keywords
});
```

### 3.3 Grouping Function

```matlab
function groups = groupEpochsByKey(epochs, splitKey)
    % Group epochs by value at split key
    %
    % Returns: Cell array of structs with fields:
    %   .value  - The split value
    %   .epochs - Cell array of epochs with this value

    valueMap = containers.Map();

    for i = 1:length(epochs)
        epoch = epochs{i};

        % Get split value
        if isa(splitKey, 'function_handle')
            value = splitKey(epoch);
        else
            value = resolveKeyPath(epoch, splitKey);
        end

        % Convert to string key for map
        valueKey = valueToKey(value);

        % Add to group
        if valueMap.isKey(valueKey)
            valueMap(valueKey) = [valueMap(valueKey), {epoch}];
        else
            valueMap(valueKey) = {epoch};
        end
    end

    % Convert map to cell array of structs
    keys = valueMap.keys();
    groups = cell(length(keys), 1);
    for i = 1:length(keys)
        groups{i}.value = keyToValue(keys{i});
        groups{i}.epochs = valueMap(keys{i});
    end
end
```

---

## 4. DATA STRUCTURES

### 4.1 EpochTree Class

```matlab
classdef EpochTree < handle
    % Hierarchical tree node for organizing epochs
    %
    % Equivalent to: edu.washington.rieke.jauimodel.AuiEpochTree

    properties
        % Tree structure
        splitKey            % Key used to split at this node
        splitValue          % Value at this split
        parent              % Parent EpochTree (empty for root)
        children            % Cell array of child EpochTree nodes

        % Leaf data
        isLeaf = false      % True if this node contains epochs
        epochList           % Cell array of epochs (only for leaves)

        % Custom properties (replaces Java HashMap)
        custom = struct()   % User-defined properties
            % custom.isSelected - Selection state
            % custom.isExample - Example flag
            % custom.display - Appearance settings
            % custom.results - Analysis results

        % Tree metadata
        splitKeyPaths       % Array of all split keys (root only)
    end

    methods
        %% Constructor
        function obj = EpochTree()
            obj.children = {};
            obj.custom.isSelected = false;
            obj.custom.isExample = false;
            obj.custom.display = struct('name', '', 'color', [0 0 0], 'backgroundColor', 'none');
        end

        %% Tree Navigation
        function leaves = leafNodes(obj)
            % Get all leaf nodes under this node
            if obj.isLeaf
                leaves = {obj};
            else
                leaves = {};
                for i = 1:length(obj.children)
                    leaves = [leaves, obj.children{i}.leafNodes()];
                end
            end
        end

        function all = descendentsDepthFirst(obj)
            % Get all descendants in depth-first order
            all = {obj};
            for i = 1:length(obj.children)
                all = [all, obj.children{i}.descendentsDepthFirst()];
            end
        end

        function child = childBySplitValue(obj, value)
            % Find child by its split value
            for i = 1:length(obj.children)
                if isequal(obj.children{i}.splitValue, value)
                    child = obj.children{i};
                    return;
                end
            end
            child = [];
        end

        function child = childAt(obj, idx)
            % Get child by 1-based index
            child = obj.children{idx};
        end

        function n = childrenLength(obj)
            % Get number of children
            n = length(obj.children);
        end

        function ancestor = parentAt(obj, levelsUp)
            % Get ancestor N levels up (1 = parent, 2 = grandparent)
            ancestor = obj;
            for i = 1:levelsUp
                ancestor = ancestor.parent;
            end
        end

        function d = depth(obj)
            % Get depth from root (root = 0)
            d = 0;
            node = obj;
            while ~isempty(node.parent)
                d = d + 1;
                node = node.parent;
            end
        end

        function path = pathFromRoot(obj)
            % Get array of nodes from root to this node
            path = {obj};
            node = obj;
            while ~isempty(node.parent)
                node = node.parent;
                path = [{node}, path];
            end
        end

        function str = pathString(obj, sep)
            % Get human-readable path string
            if nargin < 2, sep = ' > '; end
            path = obj.pathFromRoot();
            parts = cell(1, length(path));
            for i = 1:length(path)
                if isempty(path{i}.splitValue)
                    parts{i} = 'Root';
                else
                    parts{i} = string(path{i}.splitValue);
                end
            end
            str = strjoin(parts, sep);
        end

        %% Controlled Access Methods
        function putCustom(obj, key, value)
            % Store value with controlled access (prevents direct .custom replacement)
            obj.custom.(key) = value;
        end

        function value = getCustom(obj, key)
            % Retrieve value by key (returns empty if not found)
            if isfield(obj.custom, key)
                value = obj.custom.(key);
            else
                value = [];
            end
        end

        function result = hasCustom(obj, key)
            % Check if key exists
            result = isfield(obj.custom, key);
        end

        function removeCustom(obj, key)
            % Remove key from custom
            if isfield(obj.custom, key)
                obj.custom = rmfield(obj.custom, key);
            end
        end

        function values = splitValues(obj)
            % Get all split key-value pairs from root to this node
            values = struct();
            node = obj;
            while ~isempty(node.parent)
                if ~isempty(node.splitKey)
                    keyName = getSplitKeyName(node.splitKey);
                    values.(keyName) = node.splitValue;
                end
                node = node.parent;
            end
        end

        %% Epoch Access
        function epochs = getAllEpochs(obj)
            % Get all epochs under this node (recursive)
            if obj.isLeaf
                epochs = obj.epochList;
            else
                epochs = {};
                for i = 1:length(obj.children)
                    epochs = [epochs, obj.children{i}.getAllEpochs()];
                end
            end
        end

        function n = epochCount(obj)
            % Count total epochs under this node
            n = length(obj.getAllEpochs());
        end
    end
end
```

### 4.2 Tree Navigation API

The tree provides methods for navigating in both directions:

| Method | Purpose | Returns |
|--------|---------|---------|
| **Navigate DOWN** | | |
| `childAt(idx)` | Get child by 1-based index | EpochTree node |
| `childrenLength()` | Number of children | integer |
| `childBySplitValue(value)` | Find child by split value | EpochTree node or [] |
| `leafNodes()` | Get all leaf descendants | cell array of nodes |
| **Navigate UP** | | |
| `parent` | Parent node (property) | EpochTree node or [] |
| `parentAt(n)` | Ancestor n levels up | EpochTree node |
| `getRoot()` | Root node | EpochTree node |
| `depth()` | Levels from root (root=0) | integer |
| `pathFromRoot()` | Array from root to this | cell array of nodes |
| `pathString(sep)` | Human-readable path | string |
| **Controlled Access** | | |
| `putCustom(key, value)` | Store analysis results | void |
| `getCustom(key)` | Retrieve by key | value or [] |
| `hasCustom(key)` | Check if key exists | boolean |
| `removeCustom(key)` | Delete key | void |

**Workflow Pattern:**
```matlab
% Navigate tree and analyze
for i = 1:tree.childrenLength()
    cellNode = tree.childAt(i);
    for j = 1:cellNode.childrenLength()
        protocolNode = cellNode.childAt(j);
        epochs = protocolNode.getAllEpochs(false);
        results = analyzeEpochs(epochs);
        protocolNode.putCustom('results', results);  % Store at node
    end
end

% Later query results
results = protocolNode.getCustom('results');
```

### 4.3 Epoch Struct (Maps to DATA_FORMAT_SPECIFICATION)

```matlab
% Epoch struct fields (from DATA_FORMAT_SPECIFICATION.md)
epoch = struct(...
    % Identification
    'id', 123, ...
    'label', 'Epoch 1', ...

    % Timing
    'start_time', datetime(...), ...
    'end_time', datetime(...), ...
    'frame_times_ms', [0, 16.7, 33.3, ...], ...

    % Parameters (protocol settings)
    'parameters', struct(...
        'preTime', 500, ...           % ms
        'stimTime', 1000, ...         % ms
        'tailTime', 500, ...          % ms
        'contrast', 0.5, ...
        'size', 200, ...              % microns
        ... % Protocol-specific parameters
    ), ...

    % Response data
    'responses', [...  % Array of response structs
        struct('device_name', 'Amp1', 'data', [...], 'sample_rate', 10000), ...
    ], ...

    % Stimulus data
    'stimuli', [...  % Array of stimulus structs
        struct('device_name', 'Stage', 'data', [...], 'sample_rate', 10000), ...
    ], ...

    % State (added by GUI)
    'isSelected', true, ...           % Selection state
    'includeInAnalysis', true, ...    % Analysis inclusion flag

    % Parent references (populated during load)
    'cell', cell_struct, ...          % Parent cell
    'experiment', experiment_struct   % Parent experiment
);
```

---

## 5. GUI SYSTEM

### 5.1 Main GUI: epicTreeGUI

```matlab
classdef epicTreeGUI < handle
    % Main Epoch Tree GUI
    %
    % Equivalent to: old_epochtree/.../epochTreeGUI.m

    properties
        % Data
        epochTree           % Root EpochTree node
        allEpochs           % Flat cell array of all epochs

        % UI Components
        figure
        treeBrowser         % struct with tree panel components
        plottingCanvas      % struct with viewer panel components

        % State
        showEpochs = true   % Show individual epochs in tree
        isBusy = false
    end

    properties(Hidden)
        title = 'Epic Tree GUI'
        fontSize = 14
        xDivLeft = 0.4      % Tree panel width
    end

    methods
        function obj = epicTreeGUI(dataPath, varargin)
            % Constructor
            %
            % Usage:
            %   gui = epicTreeGUI('data.mat')
            %   gui = epicTreeGUI('data.mat', 'noEpochs')

            % Load data
            obj.loadData(dataPath);

            % Parse options
            if any(strcmp(varargin, 'noEpochs'))
                obj.showEpochs = false;
            end

            % Build UI
            obj.buildUIComponents();
            obj.initTreeBrowser();
            obj.plotEpochData();
        end

        function loadData(obj, dataPath)
            % Load data from standard format .mat file
            data = load(dataPath);

            % Validate format
            if ~isfield(data, 'format_version')
                error('Invalid data format: missing format_version');
            end

            % Extract all epochs with parent references
            obj.allEpochs = extractAllEpochs(data);

            % Build default tree (by cell type)
            obj.epochTree = buildTree(obj.allEpochs, {'cell.type'});
        end

        function rebuildTree(obj, splitKeyPaths)
            % Rebuild tree with new split keys
            obj.isBusy = true;
            obj.epochTree = buildTree(obj.allEpochs, splitKeyPaths);
            obj.initTreeBrowser();
            obj.isBusy = false;
        end

        function nodes = getSelectedEpochTreeNodes(obj)
            % Get currently selected tree nodes
            % Used by analysis functions
            [nodes, ~] = obj.treeBrowser.graphTree.getSelectedNodes();

            % Convert to EpochTree nodes
            epochTreeNodes = cell(size(nodes));
            for i = 1:length(nodes)
                epochTreeNodes{i} = nodes{i}.userData;
            end
            nodes = epochTreeNodes;
        end

        % ... additional methods from comprehensive guide
    end
end
```

### 5.2 Tree Browser: graphicalTree

```matlab
classdef graphicalTree < handle
    % Interactive tree visualization component
    %
    % Equivalent to: old_epochtree/.../graphicalTree/graphicalTree.m

    properties
        name
        axes
        figure

        % Selection
        selectionSize
        selectedWidgetKeys

        % Callbacks (function handles)
        nodesExpandedFcn
        nodesCheckedFcn
        nodesSelectedFcn
        nodeBecameCheckedFcn
    end

    properties(Hidden)
        trunk           % Root graphicalTreeNode
        nodeList        % All nodes
        widgetList      % Visual widgets
        drawCount = 0
    end

    methods
        function obj = graphicalTree(ax, name)
            obj.axes = ax;
            obj.name = name;
            obj.nodeList = {};
            obj.widgetList = {};

            % Create root node
            obj.trunk = obj.newNode([], name);
            obj.trunk.isExpanded = true;
        end

        function node = newNode(obj, parent, name)
            % Create new graphicalTreeNode
            node = graphicalTreeNode(name);
            node.tree = obj;
            node.selfKey = length(obj.nodeList) + 1;
            obj.nodeList{end+1} = node;

            if ~isempty(parent)
                node.parentKey = parent.selfKey;
                node.depth = parent.depth + 1;
                parent.addChild(node);
            end
        end

        function draw(obj)
            % Render tree to axes
            obj.drawCount = 0;
            obj.trunk.includeUnburied();

            % Position and style widgets
            for i = 1:obj.drawCount
                obj.widgetList{i}.bindNode(i);
            end
        end

        function [nodes, nodeKeys] = getSelectedNodes(obj)
            % Get selected nodes
            n = length(obj.selectedWidgetKeys);
            nodes = cell(1, n);
            nodeKeys = zeros(1, n);
            for i = 1:n
                widget = obj.widgetList{obj.selectedWidgetKeys(i)};
                nodes{i} = obj.nodeList{widget.boundNodeKey};
                nodeKeys(i) = widget.boundNodeKey;
            end
        end

        % Keyboard navigation (from comprehensive guide)
        % - Up/Down arrows: navigate selection
        % - Left/Right arrows: collapse/expand
        % - 'f' key: toggle checkbox
    end
end
```

### 5.3 Single Epoch Viewer

```matlab
function singleEpoch(epochTree, panel, doInit)
    % Display single epoch data in viewer panel
    %
    % Equivalent to: old_epochtree/.../singleEpoch.m

    % Get all epochs under selected tree node
    epochs = getTreeEpochs(epochTree);
    n = length(epochs);

    if n == 0
        return;
    end

    % Create slider for epoch navigation
    figData.slider = uicontrol('Parent', panel, ...
        'Style', 'slider', ...
        'Min', 1, 'Max', n+eps, ...
        'SliderStep', [1/n, 1/n], ...
        'Value', 1, ...
        'Callback', @plotNextEpoch);

    % Create info table
    figData.infoTable = uitable('Parent', panel, ...
        'Data', {'number', []; 'date', []; 'isSelected', []; ...
                 'includeInAnalysis', []; 'parameters', []});

    % Create plot axes
    figData.plotAxes = axes('Parent', panel);

    % Initial plot
    plotNextEpoch(figData.slider, [], figData);
end

function plotNextEpoch(slider, ~, figData)
    % Plot epoch at current slider position
    epochIdx = round(get(slider, 'Value'));
    epoch = figData.epochs{epochIdx};

    % Update info table
    infoData = figData.infoTable.Data;
    infoData{1,2} = sprintf('%d of %d', epochIdx, length(figData.epochs));
    infoData{2,2} = datestr(epoch.start_time);
    infoData{3,2} = epoch.isSelected;
    infoData{4,2} = epoch.includeInAnalysis;
    set(figData.infoTable, 'Data', infoData);

    % Plot responses
    cla(figData.plotAxes);
    for i = 1:length(epoch.responses)
        resp = epoch.responses(i);
        plot(figData.plotAxes, resp.data);
        hold(figData.plotAxes, 'on');
    end
    ylabel(figData.plotAxes, 'Response');
    xlabel(figData.plotAxes, 'Sample');
end
```

---

## 6. TREE UTILITY FUNCTIONS

### 6.1 getTreeEpochs (Critical Utility)

```matlab
function epochList = getTreeEpochs(epochTree, onlySelected)
    % Get all epochs under tree node (optionally only selected)
    %
    % Equivalent to: old_epochtree/.../getTreeEpochs.m
    %
    % Usage:
    %   epochs = getTreeEpochs(tree)           % All epochs
    %   epochs = getTreeEpochs(tree, true)     % Only selected epochs

    if nargin < 2
        onlySelected = false;
    end

    epochList = {};

    if epochTree.isLeaf
        % Leaf node - get epochs directly
        if onlySelected
            for i = 1:length(epochTree.epochList)
                epoch = epochTree.epochList{i};
                if epoch.isSelected
                    epochList{end+1} = epoch;
                end
            end
        else
            epochList = epochTree.epochList;
        end
    else
        % Internal node - recurse to leaves
        leaves = epochTree.leafNodes();
        for i = 1:length(leaves)
            leaf = leaves{i};
            for j = 1:length(leaf.epochList)
                epoch = leaf.epochList{j};
                if ~onlySelected || epoch.isSelected
                    epochList{end+1} = epoch;
                end
            end
        end
    end
end
```

### 6.2 getTreeLeaves

```matlab
function leaves = getTreeLeaves(epochTree, onlySelected)
    % Get all leaf nodes (optionally only selected)
    %
    % Equivalent to: old_epochtree/.../getTreeLeaves.m

    if nargin < 2
        onlySelected = false;
    end

    allLeaves = epochTree.leafNodes();

    if ~onlySelected
        leaves = allLeaves;
    else
        leaves = {};
        for i = 1:length(allLeaves)
            leaf = allLeaves{i};
            if leaf.custom.isSelected
                leaves{end+1} = leaf;
            end
        end
    end
end
```

### 6.3 getEpochTreeSplitString

```matlab
function [splitString, shortKeys] = getEpochTreeSplitString(epochTree)
    % Get summary string of split keys
    %
    % Equivalent to: old_epochtree/.../getEpochTreeSplitString.m

    % Get a leaf node to access splitValues
    leaves = epochTree.leafNodes();
    if isempty(leaves)
        splitString = 'no leaf nodes';
        shortKeys = {''};
        return;
    end

    leaf = leaves{1};
    values = leaf.splitValues();
    keys = fieldnames(values);

    % Extract short key names (last part after dot)
    shortKeys = cell(size(keys));
    for i = 1:length(keys)
        parts = strsplit(keys{i}, '.');
        shortKeys{i} = parts{end};
    end

    splitString = strjoin(shortKeys, '-');
end
```

---

## 7. SPLITTER FUNCTIONS (14+)

### 7.1 Built-in Splitters

```matlab
%% splitOnExperimentDate.m
function value = splitOnExperimentDate(epoch)
    value = datestr(epoch.experiment.start_time, 'yyyy-mm-dd');
end

%% splitOnKeywords.m
function value = splitOnKeywords(epoch)
    if isfield(epoch, 'keywords') && ~isempty(epoch.keywords)
        value = strjoin(sort(epoch.keywords), ', ');
    else
        value = 'no keywords';
    end
end

%% splitOnCellType.m
function value = splitOnCellType(epoch)
    value = epoch.cell.type;
end

%% splitOnCellLabel.m
function value = splitOnCellLabel(epoch)
    value = epoch.cell.label;
end

%% splitOnProtocolName.m
function value = splitOnProtocolName(epoch)
    if isfield(epoch.parameters, 'protocol_name')
        value = epoch.parameters.protocol_name;
    else
        value = 'unknown';
    end
end
```

### 7.2 Parameter-Based Splitter (Generic)

```matlab
function splitFunc = splitOnParameter(paramName)
    % Create split function for any parameter
    %
    % Usage:
    %   splitFunc = splitOnParameter('contrast');
    %   tree = buildTree(epochs, {splitFunc, 'cell.label'});

    splitFunc = @(epoch) getParameterValue(epoch, paramName);
end

function value = getParameterValue(epoch, paramName)
    if isfield(epoch.parameters, paramName)
        value = epoch.parameters.(paramName);
    else
        value = 'missing';
    end
end
```

### 7.3 Complete Splitter List

| Splitter Function | Purpose |
|-------------------|---------|
| `splitOnExperimentDate` | Group by experiment date |
| `splitOnCellType` | Group by cell type (OnP, OffP, etc.) |
| `splitOnCellLabel` | Group by cell ID |
| `splitOnKeywords` | Group by epoch keywords |
| `splitOnProtocolName` | Group by protocol |
| `splitOnParameter('contrast')` | Group by contrast |
| `splitOnParameter('size')` | Group by stimulus size |
| `splitOnParameter('temporal_frequency')` | Group by temporal frequency |
| `splitOnF1F2Contrast` | Group by F1/F2 contrast |
| `splitOnF1F2Phase` | Group by F1/F2 phase |
| `splitOnRadiusOrDiameter` | Group by RF size |
| `splitOnHoldingSignal` | Group by holding potential |
| `splitOnRecKeyword` | Group by recording type |
| `splitOnPatchContrast_NatImage` | Group by natural image patch contrast |

---

## 8. ANALYSIS FUNCTIONS

### 8.1 Data Extraction Utilities

| Function | Input | Output | Purpose |
|----------|-------|--------|---------|
| `getResponseMatrix(epochList, stream)` | epochs, string | [NÃ—M] | Get response data matrix |
| `getSelectedData(epochList, stream)` | epochs, string | [nÃ—M] | Get data for selected epochs only |
| `getMeanResponseTrace(epochList, recordingType)` | epochs, string | struct | Compute meanÂ±SEM trace |
| `getResponseAmplitudeStats(epochList, recordingType)` | epochs, string | struct | Peak and integrated response stats |
| `getCycleAverageResponse(epochList, cyclePeriod)` | epochs, double | struct | Cycle-averaged response |
| `getF1F2statistics(epochList, frequency)` | epochs, double | struct | Fourier component analysis |

### 8.2 getMeanResponseTrace Implementation

```matlab
function response = getMeanResponseTrace(epochList, recordingType, varargin)
    % Compute mean response trace with statistics
    %
    % Equivalent to: old_epochtree/.../getMeanResponseTrace.m
    %
    % recordingType options:
    %   'extracellular' - PSTH from spike times
    %   'exc' or 'inh' - Current traces
    %   'iClamp' - Voltage traces

    ip = inputParser;
    ip.addRequired('epochList');
    ip.addRequired('recordingType');
    ip.addParameter('PSTHsigma', 5);  % ms
    ip.parse(epochList, recordingType, varargin{:});

    % Get sample rate and timing
    epoch1 = epochList{1};
    sampleRate = epoch1.responses(1).sample_rate;
    preTime = epoch1.parameters.preTime;  % ms
    baselinePoints = (preTime / 1e3) * sampleRate;

    % Get response matrix
    streamName = getStreamForRecordingType(recordingType);
    dataMatrix = getResponseMatrix(epochList, streamName);

    response.n = size(dataMatrix, 1);
    response.timeVector = (1:size(dataMatrix,2)) / sampleRate;

    switch recordingType
        case 'extracellular'
            % Convert to PSTH
            PSTH = computePSTH(dataMatrix, sampleRate, ip.Results.PSTHsigma);
            response.mean = mean(PSTH, 1);
            response.stdev = std(PSTH, [], 1);
            response.SEM = response.stdev / sqrt(response.n);
            response.units = 'Spikes/sec';

        case {'exc', 'inh'}
            % Baseline subtract
            baselines = mean(dataMatrix(:, 1:baselinePoints), 2);
            baselineSubtracted = dataMatrix - baselines;
            response.mean = mean(baselineSubtracted, 1);
            response.stdev = std(baselineSubtracted, [], 1);
            response.SEM = response.stdev / sqrt(response.n);
            response.units = 'pA';

        otherwise
            response.mean = mean(dataMatrix, 1);
            response.stdev = std(dataMatrix, [], 1);
            response.SEM = response.stdev / sqrt(response.n);
            response.units = '?';
    end
end
```

### 8.3 Major Analysis Functions

| Function | Purpose | Key Features |
|----------|---------|--------------|
| `RFAnalysis.m` | Receptive field analysis | DOG fitting, size tuning, RF mosaic |
| `LSTA.m` | Spike-triggered averaging | Spatiotemporal STA, RF map |
| `SpatioTemporalModel.m` | LN cascade modeling | Linear filter, nonlinearity, prediction |
| `CenterSurround.m` | Size tuning analysis | Expanding spots, surround suppression |
| `MeanSelectedNodes.m` | Multi-condition comparison | Overlay traces, statistics |
| `Interneurons.m` | Interneuron analysis | Horizontal/amacrine cells |
| `Occlusion.m` | Occlusion tuning | Context effects |

---

## 9. FILE ORGANIZATION

### Current Implementation (January 2026)

```
epicTreeGUI/
â”œâ”€â”€ epicTreeGUI.m                    # âœ… Main GUI (handle class, 597 lines)
â”œâ”€â”€ trd                              # This file
â”œâ”€â”€ README.md
â”œâ”€â”€ EPOCH_TREE_SYSTEM_COMPREHENSIVE_GUIDE.md
â”œâ”€â”€ DATA_FORMAT_SPECIFICATION.md
â”œâ”€â”€ JAUIMODEL_FUNCTION_INVENTORY.md
â”‚
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ tree/
â”‚   â”‚   â”œâ”€â”€ epicTreeTools.m          # âœ… Core tree class (1700+ lines, 20+ splitters)
â”‚   â”‚   â”‚                            #    - Navigation: childAt, childrenLength, parentAt, depth, pathFromRoot, pathString
â”‚   â”‚   â”‚                            #    - Controlled access: putCustom, getCustom, hasCustom, removeCustom
â”‚   â”‚   â””â”€â”€ CompatibilityList.m      # âœ… List wrapper for Java-style .elements() access
â”‚   â”‚
â”‚   â”œâ”€â”€ gui/
â”‚   â”‚   â”œâ”€â”€ graphicalTree.m          # âœ… Interactive tree (widget pool)
â”‚   â”‚   â”œâ”€â”€ graphicalTreeNode.m      # âœ… Tree node data
â”‚   â”‚   â”œâ”€â”€ graphicalTreeNodeWidget.m # âœ… Reusable widgets
â”‚   â”‚   â”œâ”€â”€ graphicalCheckBox.m      # âœ… Checkbox widget
â”‚   â”‚   â””â”€â”€ singleEpoch.m            # âœ… Epoch viewer
â”‚   â”‚
â”‚   â”œâ”€â”€ analysis/
â”‚   â”‚   â”œâ”€â”€ getMeanResponseTrace.m        # âœ… Mean Â± SEM
â”‚   â”‚   â”œâ”€â”€ getResponseAmplitudeStats.m   # âœ… Peak/integrated
â”‚   â”‚   â”œâ”€â”€ getCycleAverageResponse.m     # âœ… Cycle averaging
â”‚   â”‚   â””â”€â”€ getLinearFilterAndPrediction.m # âœ… Linear filter
â”‚   â”‚
â”‚   â”œâ”€â”€ splitters/
â”‚   â”‚   â”œâ”€â”€ splitOnCellType.m        # Basic splitter
â”‚   â”‚   â””â”€â”€ splitOnParameter.m       # Generic parameter splitter
â”‚   â”‚
â”‚   â”œâ”€â”€ getSelectedData.m            # âœ… CRITICAL - filtered response data
â”‚   â”œâ”€â”€ getResponseMatrix.m          # âœ… CRITICAL - response matrix
â”‚   â”œâ”€â”€ getTreeEpochs.m              # âœ… Get epochs from node
â”‚   â”œâ”€â”€ loadEpicTreeData.m           # Data loader
â”‚   â””â”€â”€ ... (other utilities)
â”‚
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ test_tree_navigation.m       # âœ… Navigation & controlled access (synthetic data)
â”‚   â””â”€â”€ test_tree_navigation_realdata.m  # âœ… Navigation tests with real H5 data
â”‚
â””â”€â”€ old_epochtree/                   # Reference (read-only)
    â””â”€â”€ MHT-analysis-package-master/
        â”œâ”€â”€ EpochListAnalysisFunctions/  # Legacy analysis to port
        â””â”€â”€ JauiModel&TreeTools/         # Legacy GUI reference
```

### Planned Additions

```
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ analysis/
â”‚   â”‚   â”œâ”€â”€ RFAnalysis.m             # ğŸ”² Port from old_epochtree
â”‚   â”‚   â”œâ”€â”€ LSTA.m                   # ğŸ”² Port from old_epochtree
â”‚   â”‚   â”œâ”€â”€ CenterSurround.m         # ğŸ”² Port from old_epochtree
â”‚   â”‚   â””â”€â”€ MeanSelectedNodes.m      # ğŸ”² Port from old_epochtree
â”‚   â”‚
â”œâ”€â”€ examples/
â”‚   â””â”€â”€ example_usage.m              # ğŸ”² Usage examples
â”‚
â””â”€â”€ docs/
    â””â”€â”€ UserGuide.md                 # ğŸ”² User documentation
```

---

## 10. IMPLEMENTATION PHASES

**Status as of January 2026: Phases 1-5 COMPLETE, Phase 6-7 PARTIAL**

### Phase 1: Core Data Layer âœ… COMPLETE
- [x] `epicTreeTools.m` class (1700+ lines with 20+ splitters)
- [x] `buildTree.m` / `buildTreeWithSplitters.m` algorithms
- [x] `loadEpicTreeData.m` data loader
- [x] Key path resolver (`getNestedValue.m`)
- [x] Basic splitter functions (20+ in epicTreeTools)
- [x] Selection state management (`custom` property, `getAllEpochs`, `setSelected`)
- [x] Navigation methods: `childAt`, `childrenLength`, `parentAt`, `depth`, `pathFromRoot`, `pathString`
- [x] Controlled access: `putCustom`, `getCustom`, `hasCustom`, `removeCustom` (prevents direct .custom replacement)

### Phase 2: GUI Framework âœ… COMPLETE
- [x] `epicTreeGUI.m` main class (handle class, 40%/60% split layout)
- [x] `graphicalTree.m` tree visualization (widget pool pattern)
- [x] `graphicalTreeNode.m` node data structure
- [x] `graphicalTreeNodeWidget.m` reusable visual widgets
- [x] `graphicalCheckBox.m` checkbox with partial state
- [x] Split key dropdown with 5 presets
- [x] Node selection/expansion with callbacks

### Phase 3: Data Viewer âœ… COMPLETE
- [x] `singleEpoch.m` epoch viewer
- [x] Response plotting with multi-stream support
- [x] Epoch navigation (slider + prev/next buttons)
- [x] Info table display (index, date, selected, protocol, parameters)
- [x] Selection/include checkboxes per epoch

### Phase 4: Data Extraction Utilities âœ… COMPLETE
- [x] `getResponseMatrix.m` (CRITICAL) - [nEpochs Ã— nSamples] matrix
- [x] `getSelectedData.m` (CRITICAL) - filters by isSelected flag
- [x] `getTreeEpochs.m` - wrapper for getAllEpochs
- [x] `getMeanResponseTrace.m` - mean Â± SEM with recording type support
- [x] `getResponseAmplitudeStats.m` - peak and integrated response
- [x] `getCycleAverageResponse.m` - cycle averaging with F1/F2
- [x] `getLinearFilterAndPrediction.m` - linear filter via cross-correlation

### Phase 5: All Splitters âœ… COMPLETE
- [x] 20+ splitter functions built into epicTreeTools.m
- [x] Generic `splitOnParameter.m`
- [x] Programmatic split configuration (user defines split keys in code, not dropdown)
- [x] Mixed key paths + function handles supported via `buildTreeWithSplitters()`

### Phase 6: Analysis Functions âš ï¸ PARTIAL
- [x] `getMeanResponseTrace.m` âœ…
- [x] `getResponseAmplitudeStats.m` âœ…
- [x] `getCycleAverageResponse.m` âœ…
- [x] `getLinearFilterAndPrediction.m` âœ…
- [ ] `RFAnalysis.m` (legacy exists in old_epochtree/)
- [ ] `LSTA.m` (legacy exists in old_epochtree/)
- [ ] `SpatioTemporalModel.m`
- [ ] `CenterSurround.m` (legacy exists in old_epochtree/)
- [ ] `MeanSelectedNodes.m` (legacy exists in old_epochtree/)

### Phase 7: Polish & Documentation âš ï¸ PARTIAL
- [x] Keyboard navigation (arrows + 'f' key)
- [x] Example flagging (Set Example button)
- [ ] User documentation
- [ ] Example workflows

---

## 11. SUCCESS CRITERIA

### Minimum Viable Product (MVP) âœ… ACHIEVED
- [x] Loads standard format .mat file
- [x] Builds tree with at least 3 split types (cell type, contrast, protocol, date, combinations)
- [x] Interactive tree browser (expand/collapse/select)
- [x] Single epoch viewer with response plot
- [x] `getSelectedData()` works correctly (filters by isSelected flag)

### Full Feature Parity âš ï¸ ~70% COMPLETE
- [x] 20+ splitters implemented (in epicTreeTools.m)
- [x] 4 core analysis functions working (getMeanResponseTrace, getResponseAmplitudeStats, getCycleAverageResponse, getLinearFilterAndPrediction)
- [x] All data extraction utilities (getResponseMatrix, getSelectedData, getTreeEpochs)
- [x] Keyboard navigation (arrows, 'f' key)
- [x] Example flagging (Set Example button, red background)
- [x] Results storage on nodes (custom.results struct)
- [ ] Port remaining 4 analysis functions (RFAnalysis, LSTA, CenterSurround, MeanSelectedNodes)

---

## 12. KEY DIFFERENCES FROM LEGACY SYSTEM

| Aspect | Legacy (Java+MATLAB) | New (Pure MATLAB) |
|--------|---------------------|-------------------|
| **Data Source** | Symphony H5 via Java JNI | Standard .mat file |
| **Tree Nodes** | `AuiEpochTree` Java objects | `EpochTree` MATLAB class |
| **Custom Props** | Java `HashMap` | MATLAB struct |
| **Data Access** | `riekesuite.getResponseMatrix` | `getResponseMatrix.m` |
| **Split Functions** | `SplitValueFunctionAdapter` | Function handles |
| **Key Paths** | Java property access | MATLAB dot notation |
| **GUI** | Java Swing + MATLAB | Pure MATLAB |

---

**END OF TRD**
